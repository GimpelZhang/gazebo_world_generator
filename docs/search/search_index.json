{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pcg_gazebo : A Python package for rapid-prototyping and scripting of simulations for Gazebo \u00b6 The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information. Purpose of the project \u00b6 This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262). Installation \u00b6 Using pip \u00b6 You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager . From source \u00b6 First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git pip install . Using the package with ROS and Gazebo \u00b6 Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-* License \u00b6 Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"Home"},{"location":"#pcg_gazebo-a-python-package-for-rapid-prototyping-and-scripting-of-simulations-for-gazebo","text":"The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information.","title":"pcg_gazebo: A Python package for rapid-prototyping and scripting of simulations for Gazebo"},{"location":"#purpose-of-the-project","text":"This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262).","title":"Purpose of the project"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-pip","text":"You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager .","title":"Using pip"},{"location":"#from-source","text":"First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git pip install .","title":"From source"},{"location":"#using-the-package-with-ros-and-gazebo","text":"Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-*","title":"Using the package with ROS and Gazebo"},{"location":"#license","text":"Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"License"},{"location":"examples/","text":"This folder contains a number of examples demonstrating the features of the pcg_gazebo package. To run the Jupyter notebooks, be sure to install it as pip install jupyterlab Model generation \u00b6 Creating full Gazebo models in Python \u00b6 In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo. Model group generator \u00b6 In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created. Model factory \u00b6 In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo. Generating models from a YAML configuration file \u00b6 This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME Generating models from template Jinja files \u00b6 This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation. World generation \u00b6 Dynamically generating worlds from YAML configuration file \u00b6 The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other. Parsers \u00b6 Parsing xacro files \u00b6 This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object. SDF parsers \u00b6 The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements URDF parsers \u00b6 The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements","title":"Examples"},{"location":"examples/#model-generation","text":"","title":"Model generation"},{"location":"examples/#creating-full-gazebo-models-in-python","text":"In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo.","title":"Creating full Gazebo models in Python"},{"location":"examples/#model-group-generator","text":"In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created.","title":"Model group generator"},{"location":"examples/#model-factory","text":"In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo.","title":"Model factory"},{"location":"examples/#generating-models-from-a-yaml-configuration-file","text":"This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME","title":"Generating models from a YAML configuration file"},{"location":"examples/#generating-models-from-template-jinja-files","text":"This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation.","title":"Generating models from template Jinja files"},{"location":"examples/#world-generation","text":"","title":"World generation"},{"location":"examples/#dynamically-generating-worlds-from-yaml-configuration-file","text":"The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other.","title":"Dynamically generating worlds from YAML configuration file"},{"location":"examples/#parsers","text":"","title":"Parsers"},{"location":"examples/#parsing-xacro-files","text":"This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object.","title":"Parsing xacro files"},{"location":"examples/#sdf-parsers","text":"The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements","title":"SDF parsers"},{"location":"examples/#urdf-parsers","text":"The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements","title":"URDF parsers"},{"location":"scripts/","text":"Executable scripts installed with the pcg_gazebo package for command line actions. generate_occupancy_map \u00b6 Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information. generate_pcg_world \u00b6 Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. Examples launch_pcg_world script Samples of world configuration files list_gazebo_models \u00b6 Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ list_gazebo_models process_jinja_template \u00b6 Generates a file from a Jinja template. Run process_jinja_template -h for more information. Examples gen_model_from_template script Samples of model templates written in Jinja run_model_factory \u00b6 Runs a model factory function from the creators module using a YAML file input with the model description. Run run_model_factory -h for more information. Examples gen_model_from_factory_config script Samples of model factory configuration files sdf2urdf \u00b6 Converts a SDF file into an URDF file. Run sdf2urdf -h for more information. sdflint \u00b6 Checks a SDF file for errors. Run sdflint -h for more information. spawn_sdf_model \u00b6 Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run spawn_sdf_model -h for more information. start_gazebo_world \u00b6 Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run start_gazebo_world -h for more information. urdf2sdf \u00b6 Converts an URDF file into a SDF file. Run urdf2sdf -h for more information. urdflint \u00b6 Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run urdflint -h for more information. view_gazebo_model \u00b6 Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run list_gazebo_models . Examples $ view_gazebo_model --model MODEL_NAME # To display the visual meshes $ view_gazebo_model --model MODEL_NAME --collision # To display the collision meshes view_mesh \u00b6 Opens a mesh file and displays it. Run view_mesh -h for more information.","title":"Scripts"},{"location":"scripts/#generate_occupancy_map","text":"Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information.","title":"generate_occupancy_map"},{"location":"scripts/#generate_pcg_world","text":"Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. Examples launch_pcg_world script Samples of world configuration files","title":"generate_pcg_world"},{"location":"scripts/#list_gazebo_models","text":"Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ list_gazebo_models","title":"list_gazebo_models"},{"location":"scripts/#process_jinja_template","text":"Generates a file from a Jinja template. Run process_jinja_template -h for more information. Examples gen_model_from_template script Samples of model templates written in Jinja","title":"process_jinja_template"},{"location":"scripts/#run_model_factory","text":"Runs a model factory function from the creators module using a YAML file input with the model description. Run run_model_factory -h for more information. Examples gen_model_from_factory_config script Samples of model factory configuration files","title":"run_model_factory"},{"location":"scripts/#sdf2urdf","text":"Converts a SDF file into an URDF file. Run sdf2urdf -h for more information.","title":"sdf2urdf"},{"location":"scripts/#sdflint","text":"Checks a SDF file for errors. Run sdflint -h for more information.","title":"sdflint"},{"location":"scripts/#spawn_sdf_model","text":"Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run spawn_sdf_model -h for more information.","title":"spawn_sdf_model"},{"location":"scripts/#start_gazebo_world","text":"Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run start_gazebo_world -h for more information.","title":"start_gazebo_world"},{"location":"scripts/#urdf2sdf","text":"Converts an URDF file into a SDF file. Run urdf2sdf -h for more information.","title":"urdf2sdf"},{"location":"scripts/#urdflint","text":"Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run urdflint -h for more information.","title":"urdflint"},{"location":"scripts/#view_gazebo_model","text":"Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run list_gazebo_models . Examples $ view_gazebo_model --model MODEL_NAME # To display the visual meshes $ view_gazebo_model --model MODEL_NAME --collision # To display the collision meshes","title":"view_gazebo_model"},{"location":"scripts/#view_mesh","text":"Opens a mesh file and displays it. Run view_mesh -h for more information.","title":"view_mesh"},{"location":"reference/generators/","text":"pcg_gazebo.generators \u00b6 The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints. AssetsManager \u00b6 AssetsManager ( self ) Assets manager containing all valid Gazebo models and model group generators. This collection should be initialized as a singleton object in order to have a single source of model to all instances of engines, model and world generators. The asset types allowed to be added are: pcg_gazebo.simulation.SimulationModel : Description for a model pcg_gazebo.simulation.Light : Description for light sources pcg_gazebo.simulation.ModelGroup : Group of models and light sources pcg_gazebo.generators.ModelGroupGenerator : Dynamic model group generator dict : Input configuration of the creators factory methods for box , sphere , cylinder and mesh models, for an instance of pcg_gazebo.simulation.Light , or an instance of pcg_gazebo.generators.ModelGroupGenerator str : Name of an existing Gazebo model that can be found in the Gazebo resources path ground_planes \u00b6 list : List of strings with tags of ground plane models tags \u00b6 list : List of strings with all asset tags get_instance \u00b6 AssetsManager . get_instance () Return singleton instance of the AssetsMananger is_model \u00b6 AssetsManager . is_model ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.SimulationModel . Input arguments tag ( type: str ): Tag of the asset. is_light \u00b6 AssetsManager . is_light ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.Light . Input arguments tag ( type: str ): Tag of the asset. is_model_group \u00b6 AssetsManager . is_model_group ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.ModelGroup . Input arguments tag ( type: str ): Tag of the asset. is_gazebo_model \u00b6 AssetsManager . is_gazebo_model ( self , tag ) Return if asset identified by tag is a Gazebo model found in Gazebo's resources path. Input arguments tag ( type: str ): Tag of the asset. is_model_group_generator \u00b6 AssetsManager . is_model_group_generator ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.generators.ModelGroupGenerator . Input arguments tag ( type: str ): Tag of the asset. is_ground_plane \u00b6 AssetsManager . is_ground_plane ( self , tag ) Return if asset identified by tag is flagged as a ground plane model. Input arguments tag ( type: str ): Tag of the asset. is_factory_input \u00b6 AssetsManager . is_factory_input ( self , tag ) Return if asset identified by tag is a dict containing the inputs for a pcg_gazebo.generators.creators factory method to create a box , sphere , cylinder or mesh model. Input arguments tag ( type: str ): Tag of the asset. add \u00b6 AssetsManager . add ( self , description , tag = None , type = None , parameters = None , include_dir = None ) Add new asset to the collection. Input arguments description ( type: str , dict , pcg_gazebo.simulation.SimulationModel , pcg_gazebo.simulation.Light , pcg_gazebo.simulation.ModelGroup or pcg_gazebo.generators.ModelGroupGenerator ): Model description. tag ( type: str , default: None ): Asset's tag. If None is provided, the input description must have an attribute name which will be used as a tag, otherwise the function returns False . type ( type: str , default: None ): When the provided description is dict , the type of asset that must be generated with the dict input must be then provided as either factory , model_generator or light . Returns True , if asset could be added to the collection. get \u00b6 AssetsManager . get ( self , tag , * args , ** kwargs ) Return an asset reference by tag . Input arguments tag ( type: str ): Tag of the asset. In case tag is referencing a pcg_gazebo.generators.ModelGroupGenerator , additional inputs to run the engines can be provided using *args and **kwargs . Returns pcg_gazebo.simulation.SimulationModel or pcg_gazebo.simulation.ModelGroup . None , if tag is invalid. set_asset_as_ground_plane \u00b6 AssetsManager . set_asset_as_ground_plane ( self , tag ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments tag ( type: str ): Name of the model asset from_dict \u00b6 AssetsManager . from_dict ( self , config ) Read assets from an input dict . The dictionary should have a list of asset descriptions under the tag assets and, if necessary, a list of strings referring to models that must be flagged as ground plane under the tag ground_plane . Input arguments config ( type: data_type , default: data ): Parameter description Returns Description of return values from_yaml \u00b6 AssetsManager . from_yaml ( self , filename ) Load the assets from a YAML file. Input arguments filename ( type: str ): YAML filename. CollisionChecker \u00b6 CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. scene \u00b6 trimesh.scene.Scene : Collision check scenario reset_scenario \u00b6 CollisionChecker . reset_scenario ( self ) Remove all meshes from collision check scene. reset_to_fixed_model_scenario \u00b6 CollisionChecker . reset_to_fixed_model_scenario ( self ) Remove all meshes that were not generated by a fixed-pose engine. add_fixed_model \u00b6 CollisionChecker . add_fixed_model ( self , model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure add_model \u00b6 CollisionChecker . add_model ( self , model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure show \u00b6 CollisionChecker . show ( self ) Display the current collision check scenario using pyglet . check_collision_with_current_scene \u00b6 CollisionChecker . check_collision_with_current_scene ( self , model ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise. check_for_collisions \u00b6 CollisionChecker . check_for_collisions ( self ) Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise. ConstraintsManager \u00b6 ConstraintsManager ( self ) add \u00b6 ConstraintsManager . add ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created EngineManager \u00b6 EngineManager ( self ) add \u00b6 EngineManager . add ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. from_yaml \u00b6 EngineManager . from_yaml ( self , filename ) Load the engines from a YAML file. Input arguments filename ( type: str ): YAML filename. ModelGroupGenerator \u00b6 ModelGroupGenerator ( self , name = 'generator' ) SingletonCollisionChecker \u00b6 SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance() . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. get_instance \u00b6 SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance WorldGenerator \u00b6 WorldGenerator ( self , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo.task_manager.GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime. assets \u00b6 List of pcg_gazebo.simulation.SimulationModel : List of model assets that will be used of the world generation. constraints \u00b6 dict of pcg_gazebo.generators.constraints : Dictionary with the positioning constraints. engines \u00b6 dict of pcg_gazebo.generators.engines : Dictionary with the model creation engines. gazebo_proxy \u00b6 pcg_gazebo.task_manager.GazeboProxy : Internal instance of the GazeboProxy name \u00b6 str : Name of the generated world world \u00b6 pcg_gazebo.simulation.World : World abstraction instance init_gazebo_proxy \u00b6 WorldGenerator . init_gazebo_proxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server add_engine \u00b6 WorldGenerator . add_engine ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. add_constraint \u00b6 WorldGenerator . add_constraint ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created add_asset \u00b6 WorldGenerator . add_asset ( self , * args , ** kwargs ) Add a new model asset that can be used by the engines and added to the generated world. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model set_model_as_ground_plane \u00b6 WorldGenerator . set_model_as_ground_plane ( self , model_name ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments model_name ( type: str ): Name of the model asset get_asset \u00b6 WorldGenerator . get_asset ( self , name ) Return a simulation model asset. Input arguments name ( type: str ): Name of the model asset. Returns The model asset as pcg_gazebo.simulation.SimulationModel . None if name cannot be found in the list of model assets. get_constraint \u00b6 WorldGenerator . get_constraint ( self , name ) Return a positioning constraint configuration. Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values add_gazebo_model_as_asset \u00b6 WorldGenerator . add_gazebo_model_as_asset ( self , gazebo_model_name ) Create a model asset by importing a Gazebo model that already exists in the resources path of the catkin workspace. The model's SDF file will be parsed and converted into a pcg_gazebo.simulation.SimulationModel instance. Models that include lights can also be added, but will not be considered assets, they will just be included into the generated world SDF file. Input arguments gazebo_model_name ( type: str ): ID name from the Gazebo model to be imported Returns True if Gazebo model could be included in the assets list. is_asset \u00b6 WorldGenerator . is_asset ( self , name ) Return True if the model identified by the string name is part of the list of assets. Input arguments name ( type: str ): Name of the model add_model \u00b6 WorldGenerator . add_model ( self , model , poses ) Add an instance of pcg_gazebo.simulation.SimulationModel to the world in designed poses. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Parameter description poses ( type: list ): List of 6D pose vectors add_gazebo_model \u00b6 WorldGenerator . add_gazebo_model ( self , model_name , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Add an existent Gazebo model to the world in designed poses. Input arguments model_name ( type: str ): ID name of the Gazebo model pose ( type: list ): 6D pose vector remove_asset \u00b6 WorldGenerator . remove_asset ( self , name ) Remove model asset from the list of assets. Input arguments name ( type: str ): Name of the model Returns True , if model could be removed. delete_model \u00b6 WorldGenerator . delete_model ( self , model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation. add_lights_from_gazebo_model \u00b6 WorldGenerator . add_lights_from_gazebo_model ( self , model_name ) Add light models to the generated world from a Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns True if the lights could be parsed and added to the world. from_dict \u00b6 WorldGenerator . from_dict ( self , config ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, # it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values spawn_model \u00b6 WorldGenerator . spawn_model ( self , model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo.simulation.SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [0, 0, 0] ): Spawning position wrt reference frame rot ( type: list , default: [0, 0, 0] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned. get_physics_engine \u00b6 WorldGenerator . get_physics_engine ( self , engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo.simulation.physics.Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo.simulation.physics.Physics object. run_engines \u00b6 WorldGenerator . run_engines ( self , attach_models = False ) Run all the model placement engines and add the generated models in the internal instance of the world representation. Input arguments attach_models ( type: bool , default: False ): Attach the generated models to the existent list of models in the world Returns True if all engines ran successfully. reset_world \u00b6 WorldGenerator . reset_world ( self , name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [0, 0, -9.8] ): Gravitational acceleration vector export_world \u00b6 WorldGenerator . export_world ( self , output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str plot_results \u00b6 WorldGenerator . plot_results ( self , fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"pcg_gazebo.generators"},{"location":"reference/generators/#pcg_gazebogenerators","text":"The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints.","title":"pcg_gazebo.generators"},{"location":"reference/generators/#assetsmanager","text":"AssetsManager ( self ) Assets manager containing all valid Gazebo models and model group generators. This collection should be initialized as a singleton object in order to have a single source of model to all instances of engines, model and world generators. The asset types allowed to be added are: pcg_gazebo.simulation.SimulationModel : Description for a model pcg_gazebo.simulation.Light : Description for light sources pcg_gazebo.simulation.ModelGroup : Group of models and light sources pcg_gazebo.generators.ModelGroupGenerator : Dynamic model group generator dict : Input configuration of the creators factory methods for box , sphere , cylinder and mesh models, for an instance of pcg_gazebo.simulation.Light , or an instance of pcg_gazebo.generators.ModelGroupGenerator str : Name of an existing Gazebo model that can be found in the Gazebo resources path","title":"AssetsManager"},{"location":"reference/generators/#ground_planes","text":"list : List of strings with tags of ground plane models","title":"ground_planes"},{"location":"reference/generators/#tags","text":"list : List of strings with all asset tags","title":"tags"},{"location":"reference/generators/#get_instance","text":"AssetsManager . get_instance () Return singleton instance of the AssetsMananger","title":"get_instance"},{"location":"reference/generators/#is_model","text":"AssetsManager . is_model ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.SimulationModel . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model"},{"location":"reference/generators/#is_light","text":"AssetsManager . is_light ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.Light . Input arguments tag ( type: str ): Tag of the asset.","title":"is_light"},{"location":"reference/generators/#is_model_group","text":"AssetsManager . is_model_group ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.ModelGroup . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model_group"},{"location":"reference/generators/#is_gazebo_model","text":"AssetsManager . is_gazebo_model ( self , tag ) Return if asset identified by tag is a Gazebo model found in Gazebo's resources path. Input arguments tag ( type: str ): Tag of the asset.","title":"is_gazebo_model"},{"location":"reference/generators/#is_model_group_generator","text":"AssetsManager . is_model_group_generator ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.generators.ModelGroupGenerator . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model_group_generator"},{"location":"reference/generators/#is_ground_plane","text":"AssetsManager . is_ground_plane ( self , tag ) Return if asset identified by tag is flagged as a ground plane model. Input arguments tag ( type: str ): Tag of the asset.","title":"is_ground_plane"},{"location":"reference/generators/#is_factory_input","text":"AssetsManager . is_factory_input ( self , tag ) Return if asset identified by tag is a dict containing the inputs for a pcg_gazebo.generators.creators factory method to create a box , sphere , cylinder or mesh model. Input arguments tag ( type: str ): Tag of the asset.","title":"is_factory_input"},{"location":"reference/generators/#add","text":"AssetsManager . add ( self , description , tag = None , type = None , parameters = None , include_dir = None ) Add new asset to the collection. Input arguments description ( type: str , dict , pcg_gazebo.simulation.SimulationModel , pcg_gazebo.simulation.Light , pcg_gazebo.simulation.ModelGroup or pcg_gazebo.generators.ModelGroupGenerator ): Model description. tag ( type: str , default: None ): Asset's tag. If None is provided, the input description must have an attribute name which will be used as a tag, otherwise the function returns False . type ( type: str , default: None ): When the provided description is dict , the type of asset that must be generated with the dict input must be then provided as either factory , model_generator or light . Returns True , if asset could be added to the collection.","title":"add"},{"location":"reference/generators/#get","text":"AssetsManager . get ( self , tag , * args , ** kwargs ) Return an asset reference by tag . Input arguments tag ( type: str ): Tag of the asset. In case tag is referencing a pcg_gazebo.generators.ModelGroupGenerator , additional inputs to run the engines can be provided using *args and **kwargs . Returns pcg_gazebo.simulation.SimulationModel or pcg_gazebo.simulation.ModelGroup . None , if tag is invalid.","title":"get"},{"location":"reference/generators/#set_asset_as_ground_plane","text":"AssetsManager . set_asset_as_ground_plane ( self , tag ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments tag ( type: str ): Name of the model asset","title":"set_asset_as_ground_plane"},{"location":"reference/generators/#from_dict","text":"AssetsManager . from_dict ( self , config ) Read assets from an input dict . The dictionary should have a list of asset descriptions under the tag assets and, if necessary, a list of strings referring to models that must be flagged as ground plane under the tag ground_plane . Input arguments config ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"from_dict"},{"location":"reference/generators/#from_yaml","text":"AssetsManager . from_yaml ( self , filename ) Load the assets from a YAML file. Input arguments filename ( type: str ): YAML filename.","title":"from_yaml"},{"location":"reference/generators/#collisionchecker","text":"CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"CollisionChecker"},{"location":"reference/generators/#scene","text":"trimesh.scene.Scene : Collision check scenario","title":"scene"},{"location":"reference/generators/#reset_scenario","text":"CollisionChecker . reset_scenario ( self ) Remove all meshes from collision check scene.","title":"reset_scenario"},{"location":"reference/generators/#reset_to_fixed_model_scenario","text":"CollisionChecker . reset_to_fixed_model_scenario ( self ) Remove all meshes that were not generated by a fixed-pose engine.","title":"reset_to_fixed_model_scenario"},{"location":"reference/generators/#add_fixed_model","text":"CollisionChecker . add_fixed_model ( self , model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure","title":"add_fixed_model"},{"location":"reference/generators/#add_model","text":"CollisionChecker . add_model ( self , model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure","title":"add_model"},{"location":"reference/generators/#show","text":"CollisionChecker . show ( self ) Display the current collision check scenario using pyglet .","title":"show"},{"location":"reference/generators/#check_collision_with_current_scene","text":"CollisionChecker . check_collision_with_current_scene ( self , model ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise.","title":"check_collision_with_current_scene"},{"location":"reference/generators/#check_for_collisions","text":"CollisionChecker . check_for_collisions ( self ) Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise.","title":"check_for_collisions"},{"location":"reference/generators/#constraintsmanager","text":"ConstraintsManager ( self )","title":"ConstraintsManager"},{"location":"reference/generators/#add_1","text":"ConstraintsManager . add ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created","title":"add"},{"location":"reference/generators/#enginemanager","text":"EngineManager ( self )","title":"EngineManager"},{"location":"reference/generators/#add_2","text":"EngineManager . add ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine.","title":"add"},{"location":"reference/generators/#from_yaml_1","text":"EngineManager . from_yaml ( self , filename ) Load the engines from a YAML file. Input arguments filename ( type: str ): YAML filename.","title":"from_yaml"},{"location":"reference/generators/#modelgroupgenerator","text":"ModelGroupGenerator ( self , name = 'generator' )","title":"ModelGroupGenerator"},{"location":"reference/generators/#singletoncollisionchecker","text":"SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance() . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"SingletonCollisionChecker"},{"location":"reference/generators/#get_instance_1","text":"SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance","title":"get_instance"},{"location":"reference/generators/#worldgenerator","text":"WorldGenerator ( self , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo.task_manager.GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime.","title":"WorldGenerator"},{"location":"reference/generators/#assets","text":"List of pcg_gazebo.simulation.SimulationModel : List of model assets that will be used of the world generation.","title":"assets"},{"location":"reference/generators/#constraints","text":"dict of pcg_gazebo.generators.constraints : Dictionary with the positioning constraints.","title":"constraints"},{"location":"reference/generators/#engines","text":"dict of pcg_gazebo.generators.engines : Dictionary with the model creation engines.","title":"engines"},{"location":"reference/generators/#gazebo_proxy","text":"pcg_gazebo.task_manager.GazeboProxy : Internal instance of the GazeboProxy","title":"gazebo_proxy"},{"location":"reference/generators/#name","text":"str : Name of the generated world","title":"name"},{"location":"reference/generators/#world","text":"pcg_gazebo.simulation.World : World abstraction instance","title":"world"},{"location":"reference/generators/#init_gazebo_proxy","text":"WorldGenerator . init_gazebo_proxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server","title":"init_gazebo_proxy"},{"location":"reference/generators/#add_engine","text":"WorldGenerator . add_engine ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine.","title":"add_engine"},{"location":"reference/generators/#add_constraint","text":"WorldGenerator . add_constraint ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created","title":"add_constraint"},{"location":"reference/generators/#add_asset","text":"WorldGenerator . add_asset ( self , * args , ** kwargs ) Add a new model asset that can be used by the engines and added to the generated world. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model","title":"add_asset"},{"location":"reference/generators/#set_model_as_ground_plane","text":"WorldGenerator . set_model_as_ground_plane ( self , model_name ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments model_name ( type: str ): Name of the model asset","title":"set_model_as_ground_plane"},{"location":"reference/generators/#get_asset","text":"WorldGenerator . get_asset ( self , name ) Return a simulation model asset. Input arguments name ( type: str ): Name of the model asset. Returns The model asset as pcg_gazebo.simulation.SimulationModel . None if name cannot be found in the list of model assets.","title":"get_asset"},{"location":"reference/generators/#get_constraint","text":"WorldGenerator . get_constraint ( self , name ) Return a positioning constraint configuration. Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"get_constraint"},{"location":"reference/generators/#add_gazebo_model_as_asset","text":"WorldGenerator . add_gazebo_model_as_asset ( self , gazebo_model_name ) Create a model asset by importing a Gazebo model that already exists in the resources path of the catkin workspace. The model's SDF file will be parsed and converted into a pcg_gazebo.simulation.SimulationModel instance. Models that include lights can also be added, but will not be considered assets, they will just be included into the generated world SDF file. Input arguments gazebo_model_name ( type: str ): ID name from the Gazebo model to be imported Returns True if Gazebo model could be included in the assets list.","title":"add_gazebo_model_as_asset"},{"location":"reference/generators/#is_asset","text":"WorldGenerator . is_asset ( self , name ) Return True if the model identified by the string name is part of the list of assets. Input arguments name ( type: str ): Name of the model","title":"is_asset"},{"location":"reference/generators/#add_model_1","text":"WorldGenerator . add_model ( self , model , poses ) Add an instance of pcg_gazebo.simulation.SimulationModel to the world in designed poses. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Parameter description poses ( type: list ): List of 6D pose vectors","title":"add_model"},{"location":"reference/generators/#add_gazebo_model","text":"WorldGenerator . add_gazebo_model ( self , model_name , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Add an existent Gazebo model to the world in designed poses. Input arguments model_name ( type: str ): ID name of the Gazebo model pose ( type: list ): 6D pose vector","title":"add_gazebo_model"},{"location":"reference/generators/#remove_asset","text":"WorldGenerator . remove_asset ( self , name ) Remove model asset from the list of assets. Input arguments name ( type: str ): Name of the model Returns True , if model could be removed.","title":"remove_asset"},{"location":"reference/generators/#delete_model","text":"WorldGenerator . delete_model ( self , model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation.","title":"delete_model"},{"location":"reference/generators/#add_lights_from_gazebo_model","text":"WorldGenerator . add_lights_from_gazebo_model ( self , model_name ) Add light models to the generated world from a Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns True if the lights could be parsed and added to the world.","title":"add_lights_from_gazebo_model"},{"location":"reference/generators/#from_dict_1","text":"WorldGenerator . from_dict ( self , config ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, # it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values","title":"from_dict"},{"location":"reference/generators/#spawn_model","text":"WorldGenerator . spawn_model ( self , model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo.simulation.SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [0, 0, 0] ): Spawning position wrt reference frame rot ( type: list , default: [0, 0, 0] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned.","title":"spawn_model"},{"location":"reference/generators/#get_physics_engine","text":"WorldGenerator . get_physics_engine ( self , engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo.simulation.physics.Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo.simulation.physics.Physics object.","title":"get_physics_engine"},{"location":"reference/generators/#run_engines","text":"WorldGenerator . run_engines ( self , attach_models = False ) Run all the model placement engines and add the generated models in the internal instance of the world representation. Input arguments attach_models ( type: bool , default: False ): Attach the generated models to the existent list of models in the world Returns True if all engines ran successfully.","title":"run_engines"},{"location":"reference/generators/#reset_world","text":"WorldGenerator . reset_world ( self , name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [0, 0, -9.8] ): Gravitational acceleration vector","title":"reset_world"},{"location":"reference/generators/#export_world","text":"WorldGenerator . export_world ( self , output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str","title":"export_world"},{"location":"reference/generators/#plot_results","text":"WorldGenerator . plot_results ( self , fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"plot_results"},{"location":"reference/generators_components/","text":"pcg_gazebo.generators.components \u00b6 HingedDoor \u00b6 HingedDoor ( self , door_mesh_filename = None , width = 0.6 , thickness = 0.04 , height = 2.0 , mass = 10 , set_origin_to_ground = True , fix_to_world = True , hand_convention = 'LH' , max_opening_angle = 1.5707963267948966 , name = 'door' , frame_mesh_filename = None , with_frame = True , frame_width = 0.05 , frame_height = 0.05 , frame_depth = 0.05 ) Walls \u00b6 Walls ( self , height , thickness = 0.1 , geometries = None , model_name = 'wall' , cap_style = 'square' , join_style = 'mitre' )","title":"pcg_gazebo.generators.components"},{"location":"reference/generators_components/#pcg_gazebogeneratorscomponents","text":"","title":"pcg_gazebo.generators.components"},{"location":"reference/generators_components/#hingeddoor","text":"HingedDoor ( self , door_mesh_filename = None , width = 0.6 , thickness = 0.04 , height = 2.0 , mass = 10 , set_origin_to_ground = True , fix_to_world = True , hand_convention = 'LH' , max_opening_angle = 1.5707963267948966 , name = 'door' , frame_mesh_filename = None , with_frame = True , frame_width = 0.05 , frame_height = 0.05 , frame_depth = 0.05 )","title":"HingedDoor"},{"location":"reference/generators_components/#walls","text":"Walls ( self , height , thickness = 0.1 , geometries = None , model_name = 'wall' , cap_style = 'square' , join_style = 'mitre' )","title":"Walls"},{"location":"reference/generators_constraints/","text":"pcg_gazebo.generators.constraints \u00b6 Spatial constraints for the placement of simulation entities into the world. Constraint \u00b6 Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class. TangentConstraint \u00b6 TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented ) apply_constraint \u00b6 TangentConstraint . apply_constraint ( self , model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference WorkspaceConstraint \u00b6 WorkspaceConstraint ( self , geometry = None , frame = 'world' , holes = None ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace generate_geometry \u00b6 WorkspaceConstraint . generate_geometry ( self , type , description ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry get_bounds \u00b6 WorkspaceConstraint . get_bounds ( self ) Return the polygon bounds get_random_position \u00b6 WorkspaceConstraint . get_random_position ( self ) Return a random position that belongs to the workspace contains_point \u00b6 WorkspaceConstraint . contains_point ( self , point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy.ndarray ): 2D point contains_polygons \u00b6 WorkspaceConstraint . contains_polygons ( self , polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely.Polygon ): List of polygons get_geometry \u00b6 WorkspaceConstraint . get_geometry ( self ) Return the workspace geometry","title":"pcg_gazebo.generators.constraints"},{"location":"reference/generators_constraints/#pcg_gazebogeneratorsconstraints","text":"Spatial constraints for the placement of simulation entities into the world.","title":"pcg_gazebo.generators.constraints"},{"location":"reference/generators_constraints/#constraint","text":"Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class.","title":"Constraint"},{"location":"reference/generators_constraints/#tangentconstraint","text":"TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented )","title":"TangentConstraint"},{"location":"reference/generators_constraints/#apply_constraint","text":"TangentConstraint . apply_constraint ( self , model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference","title":"apply_constraint"},{"location":"reference/generators_constraints/#workspaceconstraint","text":"WorkspaceConstraint ( self , geometry = None , frame = 'world' , holes = None ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace","title":"WorkspaceConstraint"},{"location":"reference/generators_constraints/#generate_geometry","text":"WorkspaceConstraint . generate_geometry ( self , type , description ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry","title":"generate_geometry"},{"location":"reference/generators_constraints/#get_bounds","text":"WorkspaceConstraint . get_bounds ( self ) Return the polygon bounds","title":"get_bounds"},{"location":"reference/generators_constraints/#get_random_position","text":"WorkspaceConstraint . get_random_position ( self ) Return a random position that belongs to the workspace","title":"get_random_position"},{"location":"reference/generators_constraints/#contains_point","text":"WorkspaceConstraint . contains_point ( self , point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy.ndarray ): 2D point","title":"contains_point"},{"location":"reference/generators_constraints/#contains_polygons","text":"WorkspaceConstraint . contains_polygons ( self , polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely.Polygon ): List of polygons","title":"contains_polygons"},{"location":"reference/generators_constraints/#get_geometry","text":"WorkspaceConstraint . get_geometry ( self ) Return the workspace geometry","title":"get_geometry"},{"location":"reference/generators_engines/","text":"pcg_gazebo.generators.engines \u00b6 Pose generator engine definitions that compute the pose of the models according to pre-defined rules. Engine \u00b6 Engine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , constraints = None , collision_checker = None ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. Input arguments callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. label \u00b6 str : Engine name identifier models \u00b6 List of str : List of model name tags regarding the engine's model assets poses \u00b6 dict : List of fixed poses associated with model names. add_local_constraint \u00b6 Engine . add_local_constraint ( self , model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition get_local_constraints_for_model \u00b6 Engine . get_local_constraints_for_model ( self , model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned. apply_local_constraints \u00b6 Engine . apply_local_constraints ( self , model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model instance Returns pcg_gazebo.simulation.SimulationModel : Model with modified pose. add_model \u00b6 Engine . add_model ( self , model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model set_fixed_pose_models \u00b6 Engine . set_fixed_pose_models ( self , models ) Function description Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values run \u00b6 Engine . run ( self ) This function should be implemented by the derived classes. FixedPoseEngine \u00b6 FixedPoseEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , collision_checker = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses. add_pose \u00b6 FixedPoseEngine . add_pose ( self , pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses. run \u00b6 FixedPoseEngine . run ( self ) Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo.simulation.SimulationModel : Model instances. PatternEngine \u00b6 PatternEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], mode = None , args = None , collision_checker = None ) RandomPoseEngine \u00b6 RandomPoseEngine ( self , assets_manager = None , callback_fcn_get_constraint = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' , collision_checker = None ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments assets_manager ( type: pcg_gazebo.generators.AssetsManager ) callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on # workspaces, check the # class definition for # `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793 reset_counter \u00b6 RandomPoseEngine . reset_counter ( self ) Reset all model counters. increase_counter \u00b6 RandomPoseEngine . increase_counter ( self , name ) Increase the counter for a model. Input arguments name ( type: str ): Model name get_num_models \u00b6 RandomPoseEngine . get_num_models ( self , name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models get_max_num_models \u00b6 RandomPoseEngine . get_max_num_models ( self , name ) Return the defined maximum number of instances for a model. Input arguments name ( type: str ): Model name Returns int : Maximum number of instances choose_model \u00b6 RandomPoseEngine . choose_model ( self , models = None ) Select the next model instance to be placed in the world. This method is affected by the constructor input model_picker . In case the model_picker option was set as random , a random model will be chosen from the assets available. If it is area , the models will be ordered by footprint size and the models are chosen by an descending footprint size. Returns pcg_gazebo.simulation.SimulationModel : Chosen model is_model_in_workspace \u00b6 RandomPoseEngine . is_model_in_workspace ( self , model ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace get_list_of_footprint_polygons \u00b6 RandomPoseEngine . get_list_of_footprint_polygons ( self , footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely.geometry.Polygon : List of footprint polygons has_collision \u00b6 RandomPoseEngine . has_collision ( self , model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Returns bool : True , if any collision is detected run \u00b6 RandomPoseEngine . run ( self ) Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo.simulation.SimulationModel","title":"pcg_gazebo.generators.engines"},{"location":"reference/generators_engines/#pcg_gazebogeneratorsengines","text":"Pose generator engine definitions that compute the pose of the models according to pre-defined rules.","title":"pcg_gazebo.generators.engines"},{"location":"reference/generators_engines/#engine","text":"Engine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , constraints = None , collision_checker = None ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. Input arguments callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets.","title":"Engine"},{"location":"reference/generators_engines/#label","text":"str : Engine name identifier","title":"label"},{"location":"reference/generators_engines/#models","text":"List of str : List of model name tags regarding the engine's model assets","title":"models"},{"location":"reference/generators_engines/#poses","text":"dict : List of fixed poses associated with model names.","title":"poses"},{"location":"reference/generators_engines/#add_local_constraint","text":"Engine . add_local_constraint ( self , model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition","title":"add_local_constraint"},{"location":"reference/generators_engines/#get_local_constraints_for_model","text":"Engine . get_local_constraints_for_model ( self , model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned.","title":"get_local_constraints_for_model"},{"location":"reference/generators_engines/#apply_local_constraints","text":"Engine . apply_local_constraints ( self , model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model instance Returns pcg_gazebo.simulation.SimulationModel : Model with modified pose.","title":"apply_local_constraints"},{"location":"reference/generators_engines/#add_model","text":"Engine . add_model ( self , model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model","title":"add_model"},{"location":"reference/generators_engines/#set_fixed_pose_models","text":"Engine . set_fixed_pose_models ( self , models ) Function description Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"set_fixed_pose_models"},{"location":"reference/generators_engines/#run","text":"Engine . run ( self ) This function should be implemented by the derived classes.","title":"run"},{"location":"reference/generators_engines/#fixedposeengine","text":"FixedPoseEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , collision_checker = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"FixedPoseEngine"},{"location":"reference/generators_engines/#add_pose","text":"FixedPoseEngine . add_pose ( self , pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"add_pose"},{"location":"reference/generators_engines/#run_1","text":"FixedPoseEngine . run ( self ) Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo.simulation.SimulationModel : Model instances.","title":"run"},{"location":"reference/generators_engines/#patternengine","text":"PatternEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], mode = None , args = None , collision_checker = None )","title":"PatternEngine"},{"location":"reference/generators_engines/#randomposeengine","text":"RandomPoseEngine ( self , assets_manager = None , callback_fcn_get_constraint = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' , collision_checker = None ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments assets_manager ( type: pcg_gazebo.generators.AssetsManager ) callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on # workspaces, check the # class definition for # `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793","title":"RandomPoseEngine"},{"location":"reference/generators_engines/#reset_counter","text":"RandomPoseEngine . reset_counter ( self ) Reset all model counters.","title":"reset_counter"},{"location":"reference/generators_engines/#increase_counter","text":"RandomPoseEngine . increase_counter ( self , name ) Increase the counter for a model. Input arguments name ( type: str ): Model name","title":"increase_counter"},{"location":"reference/generators_engines/#get_num_models","text":"RandomPoseEngine . get_num_models ( self , name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models","title":"get_num_models"},{"location":"reference/generators_engines/#get_max_num_models","text":"RandomPoseEngine . get_max_num_models ( self , name ) Return the defined maximum number of instances for a model. Input arguments name ( type: str ): Model name Returns int : Maximum number of instances","title":"get_max_num_models"},{"location":"reference/generators_engines/#choose_model","text":"RandomPoseEngine . choose_model ( self , models = None ) Select the next model instance to be placed in the world. This method is affected by the constructor input model_picker . In case the model_picker option was set as random , a random model will be chosen from the assets available. If it is area , the models will be ordered by footprint size and the models are chosen by an descending footprint size. Returns pcg_gazebo.simulation.SimulationModel : Chosen model","title":"choose_model"},{"location":"reference/generators_engines/#is_model_in_workspace","text":"RandomPoseEngine . is_model_in_workspace ( self , model ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace","title":"is_model_in_workspace"},{"location":"reference/generators_engines/#get_list_of_footprint_polygons","text":"RandomPoseEngine . get_list_of_footprint_polygons ( self , footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely.geometry.Polygon : List of footprint polygons","title":"get_list_of_footprint_polygons"},{"location":"reference/generators_engines/#has_collision","text":"RandomPoseEngine . has_collision ( self , model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Returns bool : True , if any collision is detected","title":"has_collision"},{"location":"reference/generators_engines/#run_2","text":"RandomPoseEngine . run ( self ) Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo.simulation.SimulationModel","title":"run"},{"location":"reference/log/","text":"pcg_gazebo.log \u00b6 Global logging methods. update_log_dir \u00b6 update_log_dir ( add_timestamp = True ) Update the output folder for log files. Input arguments add_timestamp ( type: bool , default: True ): Add timestamp to folder name. change_log_root_dir \u00b6 change_log_root_dir ( root_dir , update_log_dir = False , add_timestamp = True ) Change the directory for the output log files. Input arguments root_dir ( type: str ): New output log directory. update_log_dir ( type: bool , default: False ): Update current global path for log directory. add_timestamp ( type: bool , default: True ): Add timestamp to the directory folder name. get_log_dir \u00b6 get_log_dir () Return the current output log directory. create_logger \u00b6 create_logger ( name , log_filename = None , output_dir = None , log_level = 40 ) Create new instance of the logger. Input arguments name ( type: str ): Name of the instance. log_filename ( type: str , default: None ): Name of the log filename, if None use name as filename. output_dir ( type: str , default: data ): Output log directory. If None is provided, use the current log directory PCG_LOG_DIR . log_level ( type: int , default: logging.ERROR ): Log level. Returns Logger object.","title":"pcg_gazebo.log"},{"location":"reference/log/#pcg_gazebolog","text":"Global logging methods.","title":"pcg_gazebo.log"},{"location":"reference/log/#update_log_dir","text":"update_log_dir ( add_timestamp = True ) Update the output folder for log files. Input arguments add_timestamp ( type: bool , default: True ): Add timestamp to folder name.","title":"update_log_dir"},{"location":"reference/log/#change_log_root_dir","text":"change_log_root_dir ( root_dir , update_log_dir = False , add_timestamp = True ) Change the directory for the output log files. Input arguments root_dir ( type: str ): New output log directory. update_log_dir ( type: bool , default: False ): Update current global path for log directory. add_timestamp ( type: bool , default: True ): Add timestamp to the directory folder name.","title":"change_log_root_dir"},{"location":"reference/log/#get_log_dir","text":"get_log_dir () Return the current output log directory.","title":"get_log_dir"},{"location":"reference/log/#create_logger","text":"create_logger ( name , log_filename = None , output_dir = None , log_level = 40 ) Create new instance of the logger. Input arguments name ( type: str ): Name of the instance. log_filename ( type: str , default: None ): Name of the log filename, if None use name as filename. output_dir ( type: str , default: data ): Output log directory. If None is provided, use the current log directory PCG_LOG_DIR . log_level ( type: int , default: logging.ERROR ): Log level. Returns Logger object.","title":"create_logger"},{"location":"reference/parsers/","text":"pcg_gazebo.parsers \u00b6 Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications parse_sdf \u00b6 parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_urdf \u00b6 parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_sdf_config \u00b6 parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_xml \u00b6 parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections.OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_str \u00b6 parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections.OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_dict \u00b6 parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections.OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections.OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo.parsers.types.XMLBase object. convert_to_dict \u00b6 convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo.parsers.types.XMLBase . Input arguments xml_dict ( type: collections.OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary. convert_from_string \u00b6 convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str . sdf2urdf \u00b6 sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid SDF element Returns pcg_gazebo.parsers.types.XMLBase as an URDF element. urdf2sdf \u00b6 urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid URDF element Returns pcg_gazebo.parsers.types.XMLBase as a SDF element.","title":"pcg_gazebo.parsers"},{"location":"reference/parsers/#pcg_gazeboparsers","text":"Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications","title":"pcg_gazebo.parsers"},{"location":"reference/parsers/#parse_sdf","text":"parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_sdf"},{"location":"reference/parsers/#parse_urdf","text":"parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_urdf"},{"location":"reference/parsers/#parse_sdf_config","text":"parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_sdf_config"},{"location":"reference/parsers/#parse_xml","text":"parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections.OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml"},{"location":"reference/parsers/#parse_xml_str","text":"parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections.OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml_str"},{"location":"reference/parsers/#parse_xml_dict","text":"parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections.OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections.OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_xml_dict"},{"location":"reference/parsers/#convert_to_dict","text":"convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo.parsers.types.XMLBase . Input arguments xml_dict ( type: collections.OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary.","title":"convert_to_dict"},{"location":"reference/parsers/#convert_from_string","text":"convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str .","title":"convert_from_string"},{"location":"reference/parsers/#sdf2urdf","text":"sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid SDF element Returns pcg_gazebo.parsers.types.XMLBase as an URDF element.","title":"sdf2urdf"},{"location":"reference/parsers/#urdf2sdf","text":"urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid URDF element Returns pcg_gazebo.parsers.types.XMLBase as a SDF element.","title":"urdf2sdf"},{"location":"reference/parsers_sdf/","text":"pcg_gazebo.parsers.sdf \u00b6 Accel \u00b6 Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1.4 Source <accel> (SDF 1.4) bias_mean \u00b6 Return the bias mean value SDF element, to read the value use obj.bias_mean.value bias_stddev \u00b6 Return the bias standard deviation value SDF element, to read the value use obj.bias_stddev.value mean \u00b6 Return the mean value SDF element, to read the value use obj.mean.value stddev \u00b6 Return the standard deviation value SDF element, to read the value use obj.stddev.value Accuracy \u00b6 Accuracy ( self , default = 0.001 ) Actor \u00b6 Actor ( self ) AllowAutoDisable \u00b6 AllowAutoDisable ( self , default = False ) Altimeter \u00b6 Altimeter ( self ) AlwaysOn \u00b6 AlwaysOn ( self , default = False ) Ambient \u00b6 Ambient ( self , default = [ 0 , 0 , 0 , 1 ]) AngularVelocity \u00b6 AngularVelocity ( self ) Animation \u00b6 Animation ( self ) Attenuation \u00b6 Attenuation ( self ) AutoStart \u00b6 AutoStart ( self , default = True ) Axis \u00b6 Axis ( self ) Axis2 \u00b6 Axis2 ( self ) Background \u00b6 Background ( self , default = [ 0 , 0 , 0 , 1 ]) BiasMean \u00b6 BiasMean ( self , default = 0 ) BiasStdDev \u00b6 BiasStdDev ( self , default = 0 ) Bounce \u00b6 Bounce ( self ) Box \u00b6 Box ( self ) Bullet \u00b6 Bullet ( self , mode = 'physics' ) CFMDamping \u00b6 CFMDamping ( self , default = False ) CFM \u00b6 CFM ( self , default = 0 ) Camera \u00b6 Camera ( self , mode = 'sensor' ) CastShadows \u00b6 CastShadows ( self , default = True ) CategoryBitmask \u00b6 CategoryBitmask ( self , default = 65535 ) Center \u00b6 Center ( self , default = False ) Child \u00b6 Child ( self , default = 'none' ) Clip \u00b6 Clip ( self ) Clouds \u00b6 Clouds ( self ) Coefficient \u00b6 Coefficient ( self , default = 1 ) CollideBitmask \u00b6 CollideBitmask ( self , default = 65535 ) CollideWithoutContact \u00b6 CollideWithoutContact ( self , default = False ) CollideWithoutContactBitmask \u00b6 CollideWithoutContactBitmask ( self , default = True ) Collision \u00b6 Collision ( self ) Color \u00b6 Color ( self , default = [ 1 , 1 , 1 , 1 ]) Constant \u00b6 Constant ( self , default = 0 ) Constraints \u00b6 Constraints ( self , engine = 'ode' ) Contact \u00b6 Contact ( self , mode = 'simbody' ) ContactMaxCorrectingVel \u00b6 ContactMaxCorrectingVel ( self , default = 100 ) ContactSurfaceLayer \u00b6 ContactSurfaceLayer ( self , default = 0.001 ) Cylinder \u00b6 Cylinder ( self ) Damping \u00b6 Damping ( self , default = 0 ) DelayStart \u00b6 DelayStart ( self , default = 0 ) Density \u00b6 Density ( self , default = 0 ) DepthCamera \u00b6 DepthCamera ( self ) Diffuse \u00b6 Diffuse ( self , default = [ 0 , 0 , 0 , 1 ]) Direction \u00b6 Direction ( self , default = [ 0 , 0 , - 1 ]) Dissipation \u00b6 Dissipation ( self , default = 100 ) Distortion \u00b6 Distortion ( self ) DynamicFriction \u00b6 DynamicFriction ( self , default = 0.9 ) Dynamics \u00b6 Dynamics ( self ) ERP \u00b6 ERP ( self , default = 0.2 ) Effort \u00b6 Effort ( self , default =- 1 ) ElasticModulus \u00b6 ElasticModulus ( self , default =- 1 ) Emissive \u00b6 Emissive ( self , size = 4 ) Empty \u00b6 Empty ( self ) EnableWind \u00b6 EnableWind ( self , default = False ) End \u00b6 End ( self , default = 0 ) FDir1 \u00b6 FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector FallOff \u00b6 FallOff ( self , default = 0 ) Far \u00b6 Far ( self , default = 0 ) Filename \u00b6 Filename ( self , default = 'none' ) Fog \u00b6 Fog ( self , mode = '' ) ForceTorque \u00b6 ForceTorque ( self ) Format \u00b6 Format ( self , default = 'R8G8B8' ) Frame \u00b6 Frame ( self , default = '' ) Friction \u00b6 Friction ( self ) Configuration of the collision friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Friction2 \u00b6 Friction2 ( self , default = 1 ) FrictionModel \u00b6 FrictionModel ( self ) GUI \u00b6 GUI ( self ) Geometry \u00b6 Geometry ( self , mode = 'empty' ) Granularity \u00b6 Granularity ( self , default = 1 ) Gravity \u00b6 Gravity ( self , default = True ) Grid \u00b6 Grid ( self , default = True ) Height \u00b6 Height ( self , default = 1 ) Horizontal \u00b6 Horizontal ( self ) HorizontalFOV \u00b6 HorizontalFOV ( self , default = 1.047 ) Humidity \u00b6 Humidity ( self , default = 0.5 ) IMU \u00b6 IMU ( self ) IXX \u00b6 IXX ( self , default = 0 ) IXY \u00b6 IXY ( self , default = 0 ) IXZ \u00b6 IXZ ( self , default = 0 ) IYY \u00b6 IYY ( self , default = 0 ) IYZ \u00b6 IYZ ( self , default = 0 ) IZZ \u00b6 IZZ ( self , default = 0 ) Image \u00b6 Image ( self , mode = 'geometry' ) Include \u00b6 Include ( self ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) InheritYaw \u00b6 InheritYaw ( self , default = False ) InitialPosition \u00b6 InitialPosition ( self , default = 0 ) InnerAngle \u00b6 InnerAngle ( self , default = 0 ) InterpolateX \u00b6 InterpolateX ( self , default = False ) Iters \u00b6 Iters ( self , default = 50 ) Joint \u00b6 Joint ( self ) K1 \u00b6 K1 ( self , default = 0 ) K2 \u00b6 K2 ( self , default = 0 ) K3 \u00b6 K3 ( self , default = 0 ) Kd \u00b6 Kd ( self , default = 1 ) Kinematic \u00b6 Kinematic ( self , default = False ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) LaserRetro \u00b6 LaserRetro ( self , default = 0 ) Length \u00b6 Length ( self ) Light \u00b6 Light ( self ) Lighting \u00b6 Lighting ( self , default = False ) Limit \u00b6 Limit ( self , mode = 'axis' ) Linear \u00b6 Linear ( self , default = 0 ) LinearAcceleration \u00b6 LinearAcceleration ( self ) Link \u00b6 Link ( self ) Localization \u00b6 Localization ( self , default = 'CUSTOM' ) Loop \u00b6 Loop ( self , default = False ) Lower \u00b6 Lower ( self , default =- 1e+16 ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self ) Max \u00b6 Max ( self , default = 0 ) MaxAngle \u00b6 MaxAngle ( self , default = 0 ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxDist \u00b6 MaxDist ( self , default = 0 ) MaxStepSize \u00b6 MaxStepSize ( self , default = 0.001 ) MaxTransientVelocity \u00b6 MaxTransientVelocity ( self , default = 0.01 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) Mean \u00b6 Mean ( self ) MeanSize \u00b6 MeanSize ( self , default = 0 ) MeasureDirection \u00b6 MeasureDirection ( self , default = 'child_to_parent' ) Mesh \u00b6 Mesh ( self ) Min \u00b6 Min ( self , default = 0 ) MinAngle \u00b6 MinAngle ( self , default = 0 ) MinDepth \u00b6 MinDepth ( self , default = 0 ) MinDist \u00b6 MinDist ( self , default = 0 ) MinStepSize \u00b6 MinStepSize ( self , default = 0.0001 ) Model \u00b6 Model ( self ) Mu \u00b6 Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Mu2 \u00b6 Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction MustBeLoopJoint \u00b6 MustBeLoopJoint ( self , default = False ) Name \u00b6 Name ( self , default = 'none' ) Near \u00b6 Near ( self , default = 0 ) Noise \u00b6 Noise ( self , type = 'none' ) Normal \u00b6 Normal ( self ) NormalMap \u00b6 NormalMap ( self , default = '' ) ODE \u00b6 ODE ( self , mode = 'physics' ) OrientationReferenceFrame \u00b6 OrientationReferenceFrame ( self ) OriginVisual \u00b6 OriginVisual ( self , default = True ) OuterAngle \u00b6 OuterAngle ( self , default = 0 ) Output \u00b6 Output ( self , default = 'depths' ) OverrideImpactCaptureVelocity \u00b6 OverrideImpactCaptureVelocity ( self , default = 0.001 ) OverrideStictionTransitionVelocity \u00b6 OverrideStictionTransitionVelocity ( self , default = 0.9 ) P1 \u00b6 P1 ( self , default = 0 ) P2 \u00b6 P2 ( self , default = 0 ) Parent \u00b6 Parent ( self , default = 'parent' ) PatchRadius \u00b6 PatchRadius ( self , default = 0 ) Path \u00b6 Path ( self , default = '__default__' ) Physics \u00b6 Physics ( self , mode = 'ode' ) Plane \u00b6 Plane ( self ) PlasticCoefRestitution \u00b6 PlasticCoefRestitution ( self , default = 0.5 ) PlasticImpactVelocity \u00b6 PlasticImpactVelocity ( self , default = 0.5 ) Plugin \u00b6 Plugin ( self , default = {}) Point \u00b6 Point ( self , vec_length = 2 ) PoissonsRatio \u00b6 PoissonsRatio ( self , default = 0.3 ) Polyline \u00b6 Polyline ( self ) Pose \u00b6 Pose ( self ) PreConIters \u00b6 PreConIters ( self , default = 0 ) Precision \u00b6 Precision ( self ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) Quadratic \u00b6 Quadratic ( self , default = 0 ) Radius \u00b6 Radius ( self , default = 0 ) Range \u00b6 Range ( self ) Rate \u00b6 Rate ( self , type = 'none' ) Ray \u00b6 Ray ( self ) RealTimeFactor \u00b6 RealTimeFactor ( self , default = 1 ) RealTimeUpdateRate \u00b6 RealTimeUpdateRate ( self , default = 1 ) Resolution \u00b6 Resolution ( self , default = 0 ) RestitutionCoefficient \u00b6 RestitutionCoefficient ( self , default = 0 ) RollingFriction \u00b6 RollingFriction ( self , default = 1 ) SDF \u00b6 SDF ( self , mode = 'world' ) Samples \u00b6 Samples ( self , default = 640 ) Save \u00b6 Save ( self ) Scale \u00b6 Scale ( self , size = 3 ) Scan \u00b6 Scan ( self ) Scene \u00b6 Scene ( self ) Script \u00b6 Script ( self , mode = 'material' ) SelfCollide \u00b6 SelfCollide ( self , default = False ) Sensor \u00b6 Sensor ( self , mode = 'altimeter' ) Shader \u00b6 Shader ( self ) Shadows \u00b6 Shadows ( self , default = True ) Simbody \u00b6 Simbody ( self , mode = 'physics' ) Size \u00b6 Size ( self , vec_length = 3 ) Skin \u00b6 Skin ( self ) Sky \u00b6 Sky ( self ) Slip \u00b6 Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip1 \u00b6 Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip2 \u00b6 Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient SoftCFM \u00b6 SoftCFM ( self , default = 0 ) SoftERP \u00b6 SoftERP ( self , default = 0.2 ) Solver \u00b6 Solver ( self , engine = 'ode' ) Sor \u00b6 Sor ( self , default = 1.3 ) Specular \u00b6 Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ]) Speed \u00b6 Speed ( self , default = 0.6 ) Sphere \u00b6 Sphere ( self ) SplitImpulse \u00b6 SplitImpulse ( self , default = True ) SplitImpulsePenetrationThreshold \u00b6 SplitImpulsePenetrationThreshold ( self , default =- 0.01 ) Spot \u00b6 Spot ( self ) SpringReference \u00b6 SpringReference ( self , default = 0 ) SpringStiffness \u00b6 SpringStiffness ( self , default = 0 ) Start \u00b6 Start ( self , default = 0 ) Static \u00b6 Static ( self , default = False ) StaticFriction \u00b6 StaticFriction ( self , default = 0.9 ) StdDev \u00b6 StdDev ( self ) Stiffness \u00b6 Stiffness ( self , default = 100000000.0 ) SubMesh \u00b6 SubMesh ( self ) Sunrise \u00b6 Sunrise ( self , default = 0 ) Sunset \u00b6 Sunset ( self , default = 0 ) Surface \u00b6 Surface ( self ) SurfaceRadius \u00b6 SurfaceRadius ( self , default = 0 ) Threshold \u00b6 Threshold ( self , default = 0 ) Time \u00b6 Time ( self , default = 0 ) Topic \u00b6 Topic ( self , default = 'none' ) Torsional \u00b6 Torsional ( self ) TrackVisual \u00b6 TrackVisual ( self ) Trajectory \u00b6 Trajectory ( self ) Transparency \u00b6 Transparency ( self , default = 0 ) Type \u00b6 Type ( self , default = '' ) URDF \u00b6 URDF ( self , mode = 'model' ) URI \u00b6 URI ( self , default = '' ) UpdateRate \u00b6 UpdateRate ( self , default = 0 ) Upper \u00b6 Upper ( self , default = 1e+16 ) UseDynamicMOIRescaling \u00b6 UseDynamicMOIRescaling ( self , default = False ) UseModelFrame \u00b6 UseModelFrame ( self , default = False ) UseParentModelFrame \u00b6 UseParentModelFrame ( self , default = False ) UsePatchRadius \u00b6 UsePatchRadius ( self , default = True ) Velocity \u00b6 Velocity ( self , default =- 1 ) Vertical \u00b6 Vertical ( self ) VerticalPosition \u00b6 VerticalPosition ( self ) VerticalVelocity \u00b6 VerticalVelocity ( self ) ViewController \u00b6 ViewController ( self , default = 'orbit' ) ViscousFriction \u00b6 ViscousFriction ( self , default = 0 ) Visual \u00b6 Visual ( self ) Visualize \u00b6 Visualize ( self , default = False ) Waypoint \u00b6 Waypoint ( self ) Width \u00b6 Width ( self , default = 320 ) World \u00b6 World ( self ) X \u00b6 X ( self ) XYZ \u00b6 XYZ ( self , default = [ 0 , 0 , 1 ]) Y \u00b6 Y ( self ) Z \u00b6 Z ( self )","title":"pcg_gazebo.parsers.sdf"},{"location":"reference/parsers_sdf/#pcg_gazeboparserssdf","text":"","title":"pcg_gazebo.parsers.sdf"},{"location":"reference/parsers_sdf/#accel","text":"Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1.4 Source <accel> (SDF 1.4)","title":"Accel"},{"location":"reference/parsers_sdf/#bias_mean","text":"Return the bias mean value SDF element, to read the value use obj.bias_mean.value","title":"bias_mean"},{"location":"reference/parsers_sdf/#bias_stddev","text":"Return the bias standard deviation value SDF element, to read the value use obj.bias_stddev.value","title":"bias_stddev"},{"location":"reference/parsers_sdf/#mean","text":"Return the mean value SDF element, to read the value use obj.mean.value","title":"mean"},{"location":"reference/parsers_sdf/#stddev","text":"Return the standard deviation value SDF element, to read the value use obj.stddev.value","title":"stddev"},{"location":"reference/parsers_sdf/#accuracy","text":"Accuracy ( self , default = 0.001 )","title":"Accuracy"},{"location":"reference/parsers_sdf/#actor","text":"Actor ( self )","title":"Actor"},{"location":"reference/parsers_sdf/#allowautodisable","text":"AllowAutoDisable ( self , default = False )","title":"AllowAutoDisable"},{"location":"reference/parsers_sdf/#altimeter","text":"Altimeter ( self )","title":"Altimeter"},{"location":"reference/parsers_sdf/#alwayson","text":"AlwaysOn ( self , default = False )","title":"AlwaysOn"},{"location":"reference/parsers_sdf/#ambient","text":"Ambient ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Ambient"},{"location":"reference/parsers_sdf/#angularvelocity","text":"AngularVelocity ( self )","title":"AngularVelocity"},{"location":"reference/parsers_sdf/#animation","text":"Animation ( self )","title":"Animation"},{"location":"reference/parsers_sdf/#attenuation","text":"Attenuation ( self )","title":"Attenuation"},{"location":"reference/parsers_sdf/#autostart","text":"AutoStart ( self , default = True )","title":"AutoStart"},{"location":"reference/parsers_sdf/#axis","text":"Axis ( self )","title":"Axis"},{"location":"reference/parsers_sdf/#axis2","text":"Axis2 ( self )","title":"Axis2"},{"location":"reference/parsers_sdf/#background","text":"Background ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Background"},{"location":"reference/parsers_sdf/#biasmean","text":"BiasMean ( self , default = 0 )","title":"BiasMean"},{"location":"reference/parsers_sdf/#biasstddev","text":"BiasStdDev ( self , default = 0 )","title":"BiasStdDev"},{"location":"reference/parsers_sdf/#bounce","text":"Bounce ( self )","title":"Bounce"},{"location":"reference/parsers_sdf/#box","text":"Box ( self )","title":"Box"},{"location":"reference/parsers_sdf/#bullet","text":"Bullet ( self , mode = 'physics' )","title":"Bullet"},{"location":"reference/parsers_sdf/#cfmdamping","text":"CFMDamping ( self , default = False )","title":"CFMDamping"},{"location":"reference/parsers_sdf/#cfm","text":"CFM ( self , default = 0 )","title":"CFM"},{"location":"reference/parsers_sdf/#camera","text":"Camera ( self , mode = 'sensor' )","title":"Camera"},{"location":"reference/parsers_sdf/#castshadows","text":"CastShadows ( self , default = True )","title":"CastShadows"},{"location":"reference/parsers_sdf/#categorybitmask","text":"CategoryBitmask ( self , default = 65535 )","title":"CategoryBitmask"},{"location":"reference/parsers_sdf/#center","text":"Center ( self , default = False )","title":"Center"},{"location":"reference/parsers_sdf/#child","text":"Child ( self , default = 'none' )","title":"Child"},{"location":"reference/parsers_sdf/#clip","text":"Clip ( self )","title":"Clip"},{"location":"reference/parsers_sdf/#clouds","text":"Clouds ( self )","title":"Clouds"},{"location":"reference/parsers_sdf/#coefficient","text":"Coefficient ( self , default = 1 )","title":"Coefficient"},{"location":"reference/parsers_sdf/#collidebitmask","text":"CollideBitmask ( self , default = 65535 )","title":"CollideBitmask"},{"location":"reference/parsers_sdf/#collidewithoutcontact","text":"CollideWithoutContact ( self , default = False )","title":"CollideWithoutContact"},{"location":"reference/parsers_sdf/#collidewithoutcontactbitmask","text":"CollideWithoutContactBitmask ( self , default = True )","title":"CollideWithoutContactBitmask"},{"location":"reference/parsers_sdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"reference/parsers_sdf/#color","text":"Color ( self , default = [ 1 , 1 , 1 , 1 ])","title":"Color"},{"location":"reference/parsers_sdf/#constant","text":"Constant ( self , default = 0 )","title":"Constant"},{"location":"reference/parsers_sdf/#constraints","text":"Constraints ( self , engine = 'ode' )","title":"Constraints"},{"location":"reference/parsers_sdf/#contact","text":"Contact ( self , mode = 'simbody' )","title":"Contact"},{"location":"reference/parsers_sdf/#contactmaxcorrectingvel","text":"ContactMaxCorrectingVel ( self , default = 100 )","title":"ContactMaxCorrectingVel"},{"location":"reference/parsers_sdf/#contactsurfacelayer","text":"ContactSurfaceLayer ( self , default = 0.001 )","title":"ContactSurfaceLayer"},{"location":"reference/parsers_sdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"reference/parsers_sdf/#damping","text":"Damping ( self , default = 0 )","title":"Damping"},{"location":"reference/parsers_sdf/#delaystart","text":"DelayStart ( self , default = 0 )","title":"DelayStart"},{"location":"reference/parsers_sdf/#density","text":"Density ( self , default = 0 )","title":"Density"},{"location":"reference/parsers_sdf/#depthcamera","text":"DepthCamera ( self )","title":"DepthCamera"},{"location":"reference/parsers_sdf/#diffuse","text":"Diffuse ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Diffuse"},{"location":"reference/parsers_sdf/#direction","text":"Direction ( self , default = [ 0 , 0 , - 1 ])","title":"Direction"},{"location":"reference/parsers_sdf/#dissipation","text":"Dissipation ( self , default = 100 )","title":"Dissipation"},{"location":"reference/parsers_sdf/#distortion","text":"Distortion ( self )","title":"Distortion"},{"location":"reference/parsers_sdf/#dynamicfriction","text":"DynamicFriction ( self , default = 0.9 )","title":"DynamicFriction"},{"location":"reference/parsers_sdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"reference/parsers_sdf/#erp","text":"ERP ( self , default = 0.2 )","title":"ERP"},{"location":"reference/parsers_sdf/#effort","text":"Effort ( self , default =- 1 )","title":"Effort"},{"location":"reference/parsers_sdf/#elasticmodulus","text":"ElasticModulus ( self , default =- 1 )","title":"ElasticModulus"},{"location":"reference/parsers_sdf/#emissive","text":"Emissive ( self , size = 4 )","title":"Emissive"},{"location":"reference/parsers_sdf/#empty","text":"Empty ( self )","title":"Empty"},{"location":"reference/parsers_sdf/#enablewind","text":"EnableWind ( self , default = False )","title":"EnableWind"},{"location":"reference/parsers_sdf/#end","text":"End ( self , default = 0 )","title":"End"},{"location":"reference/parsers_sdf/#fdir1","text":"FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector","title":"FDir1"},{"location":"reference/parsers_sdf/#falloff","text":"FallOff ( self , default = 0 )","title":"FallOff"},{"location":"reference/parsers_sdf/#far","text":"Far ( self , default = 0 )","title":"Far"},{"location":"reference/parsers_sdf/#filename","text":"Filename ( self , default = 'none' )","title":"Filename"},{"location":"reference/parsers_sdf/#fog","text":"Fog ( self , mode = '' )","title":"Fog"},{"location":"reference/parsers_sdf/#forcetorque","text":"ForceTorque ( self )","title":"ForceTorque"},{"location":"reference/parsers_sdf/#format","text":"Format ( self , default = 'R8G8B8' )","title":"Format"},{"location":"reference/parsers_sdf/#frame","text":"Frame ( self , default = '' )","title":"Frame"},{"location":"reference/parsers_sdf/#friction","text":"Friction ( self ) Configuration of the collision friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Friction"},{"location":"reference/parsers_sdf/#friction2","text":"Friction2 ( self , default = 1 )","title":"Friction2"},{"location":"reference/parsers_sdf/#frictionmodel","text":"FrictionModel ( self )","title":"FrictionModel"},{"location":"reference/parsers_sdf/#gui","text":"GUI ( self )","title":"GUI"},{"location":"reference/parsers_sdf/#geometry","text":"Geometry ( self , mode = 'empty' )","title":"Geometry"},{"location":"reference/parsers_sdf/#granularity","text":"Granularity ( self , default = 1 )","title":"Granularity"},{"location":"reference/parsers_sdf/#gravity","text":"Gravity ( self , default = True )","title":"Gravity"},{"location":"reference/parsers_sdf/#grid","text":"Grid ( self , default = True )","title":"Grid"},{"location":"reference/parsers_sdf/#height","text":"Height ( self , default = 1 )","title":"Height"},{"location":"reference/parsers_sdf/#horizontal","text":"Horizontal ( self )","title":"Horizontal"},{"location":"reference/parsers_sdf/#horizontalfov","text":"HorizontalFOV ( self , default = 1.047 )","title":"HorizontalFOV"},{"location":"reference/parsers_sdf/#humidity","text":"Humidity ( self , default = 0.5 )","title":"Humidity"},{"location":"reference/parsers_sdf/#imu","text":"IMU ( self )","title":"IMU"},{"location":"reference/parsers_sdf/#ixx","text":"IXX ( self , default = 0 )","title":"IXX"},{"location":"reference/parsers_sdf/#ixy","text":"IXY ( self , default = 0 )","title":"IXY"},{"location":"reference/parsers_sdf/#ixz","text":"IXZ ( self , default = 0 )","title":"IXZ"},{"location":"reference/parsers_sdf/#iyy","text":"IYY ( self , default = 0 )","title":"IYY"},{"location":"reference/parsers_sdf/#iyz","text":"IYZ ( self , default = 0 )","title":"IYZ"},{"location":"reference/parsers_sdf/#izz","text":"IZZ ( self , default = 0 )","title":"IZZ"},{"location":"reference/parsers_sdf/#image","text":"Image ( self , mode = 'geometry' )","title":"Image"},{"location":"reference/parsers_sdf/#include","text":"Include ( self )","title":"Include"},{"location":"reference/parsers_sdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"reference/parsers_sdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"reference/parsers_sdf/#inherityaw","text":"InheritYaw ( self , default = False )","title":"InheritYaw"},{"location":"reference/parsers_sdf/#initialposition","text":"InitialPosition ( self , default = 0 )","title":"InitialPosition"},{"location":"reference/parsers_sdf/#innerangle","text":"InnerAngle ( self , default = 0 )","title":"InnerAngle"},{"location":"reference/parsers_sdf/#interpolatex","text":"InterpolateX ( self , default = False )","title":"InterpolateX"},{"location":"reference/parsers_sdf/#iters","text":"Iters ( self , default = 50 )","title":"Iters"},{"location":"reference/parsers_sdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"reference/parsers_sdf/#k1","text":"K1 ( self , default = 0 )","title":"K1"},{"location":"reference/parsers_sdf/#k2","text":"K2 ( self , default = 0 )","title":"K2"},{"location":"reference/parsers_sdf/#k3","text":"K3 ( self , default = 0 )","title":"K3"},{"location":"reference/parsers_sdf/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"reference/parsers_sdf/#kinematic","text":"Kinematic ( self , default = False )","title":"Kinematic"},{"location":"reference/parsers_sdf/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"reference/parsers_sdf/#laserretro","text":"LaserRetro ( self , default = 0 )","title":"LaserRetro"},{"location":"reference/parsers_sdf/#length","text":"Length ( self )","title":"Length"},{"location":"reference/parsers_sdf/#light","text":"Light ( self )","title":"Light"},{"location":"reference/parsers_sdf/#lighting","text":"Lighting ( self , default = False )","title":"Lighting"},{"location":"reference/parsers_sdf/#limit","text":"Limit ( self , mode = 'axis' )","title":"Limit"},{"location":"reference/parsers_sdf/#linear","text":"Linear ( self , default = 0 )","title":"Linear"},{"location":"reference/parsers_sdf/#linearacceleration","text":"LinearAcceleration ( self )","title":"LinearAcceleration"},{"location":"reference/parsers_sdf/#link","text":"Link ( self )","title":"Link"},{"location":"reference/parsers_sdf/#localization","text":"Localization ( self , default = 'CUSTOM' )","title":"Localization"},{"location":"reference/parsers_sdf/#loop","text":"Loop ( self , default = False )","title":"Loop"},{"location":"reference/parsers_sdf/#lower","text":"Lower ( self , default =- 1e+16 )","title":"Lower"},{"location":"reference/parsers_sdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"reference/parsers_sdf/#material","text":"Material ( self )","title":"Material"},{"location":"reference/parsers_sdf/#max","text":"Max ( self , default = 0 )","title":"Max"},{"location":"reference/parsers_sdf/#maxangle","text":"MaxAngle ( self , default = 0 )","title":"MaxAngle"},{"location":"reference/parsers_sdf/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"reference/parsers_sdf/#maxdist","text":"MaxDist ( self , default = 0 )","title":"MaxDist"},{"location":"reference/parsers_sdf/#maxstepsize","text":"MaxStepSize ( self , default = 0.001 )","title":"MaxStepSize"},{"location":"reference/parsers_sdf/#maxtransientvelocity","text":"MaxTransientVelocity ( self , default = 0.01 )","title":"MaxTransientVelocity"},{"location":"reference/parsers_sdf/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"reference/parsers_sdf/#mean_1","text":"Mean ( self )","title":"Mean"},{"location":"reference/parsers_sdf/#meansize","text":"MeanSize ( self , default = 0 )","title":"MeanSize"},{"location":"reference/parsers_sdf/#measuredirection","text":"MeasureDirection ( self , default = 'child_to_parent' )","title":"MeasureDirection"},{"location":"reference/parsers_sdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"reference/parsers_sdf/#min","text":"Min ( self , default = 0 )","title":"Min"},{"location":"reference/parsers_sdf/#minangle","text":"MinAngle ( self , default = 0 )","title":"MinAngle"},{"location":"reference/parsers_sdf/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"reference/parsers_sdf/#mindist","text":"MinDist ( self , default = 0 )","title":"MinDist"},{"location":"reference/parsers_sdf/#minstepsize","text":"MinStepSize ( self , default = 0.0001 )","title":"MinStepSize"},{"location":"reference/parsers_sdf/#model","text":"Model ( self )","title":"Model"},{"location":"reference/parsers_sdf/#mu","text":"Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu"},{"location":"reference/parsers_sdf/#mu2","text":"Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu2"},{"location":"reference/parsers_sdf/#mustbeloopjoint","text":"MustBeLoopJoint ( self , default = False )","title":"MustBeLoopJoint"},{"location":"reference/parsers_sdf/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"reference/parsers_sdf/#near","text":"Near ( self , default = 0 )","title":"Near"},{"location":"reference/parsers_sdf/#noise","text":"Noise ( self , type = 'none' )","title":"Noise"},{"location":"reference/parsers_sdf/#normal","text":"Normal ( self )","title":"Normal"},{"location":"reference/parsers_sdf/#normalmap","text":"NormalMap ( self , default = '' )","title":"NormalMap"},{"location":"reference/parsers_sdf/#ode","text":"ODE ( self , mode = 'physics' )","title":"ODE"},{"location":"reference/parsers_sdf/#orientationreferenceframe","text":"OrientationReferenceFrame ( self )","title":"OrientationReferenceFrame"},{"location":"reference/parsers_sdf/#originvisual","text":"OriginVisual ( self , default = True )","title":"OriginVisual"},{"location":"reference/parsers_sdf/#outerangle","text":"OuterAngle ( self , default = 0 )","title":"OuterAngle"},{"location":"reference/parsers_sdf/#output","text":"Output ( self , default = 'depths' )","title":"Output"},{"location":"reference/parsers_sdf/#overrideimpactcapturevelocity","text":"OverrideImpactCaptureVelocity ( self , default = 0.001 )","title":"OverrideImpactCaptureVelocity"},{"location":"reference/parsers_sdf/#overridestictiontransitionvelocity","text":"OverrideStictionTransitionVelocity ( self , default = 0.9 )","title":"OverrideStictionTransitionVelocity"},{"location":"reference/parsers_sdf/#p1","text":"P1 ( self , default = 0 )","title":"P1"},{"location":"reference/parsers_sdf/#p2","text":"P2 ( self , default = 0 )","title":"P2"},{"location":"reference/parsers_sdf/#parent","text":"Parent ( self , default = 'parent' )","title":"Parent"},{"location":"reference/parsers_sdf/#patchradius","text":"PatchRadius ( self , default = 0 )","title":"PatchRadius"},{"location":"reference/parsers_sdf/#path","text":"Path ( self , default = '__default__' )","title":"Path"},{"location":"reference/parsers_sdf/#physics","text":"Physics ( self , mode = 'ode' )","title":"Physics"},{"location":"reference/parsers_sdf/#plane","text":"Plane ( self )","title":"Plane"},{"location":"reference/parsers_sdf/#plasticcoefrestitution","text":"PlasticCoefRestitution ( self , default = 0.5 )","title":"PlasticCoefRestitution"},{"location":"reference/parsers_sdf/#plasticimpactvelocity","text":"PlasticImpactVelocity ( self , default = 0.5 )","title":"PlasticImpactVelocity"},{"location":"reference/parsers_sdf/#plugin","text":"Plugin ( self , default = {})","title":"Plugin"},{"location":"reference/parsers_sdf/#point","text":"Point ( self , vec_length = 2 )","title":"Point"},{"location":"reference/parsers_sdf/#poissonsratio","text":"PoissonsRatio ( self , default = 0.3 )","title":"PoissonsRatio"},{"location":"reference/parsers_sdf/#polyline","text":"Polyline ( self )","title":"Polyline"},{"location":"reference/parsers_sdf/#pose","text":"Pose ( self )","title":"Pose"},{"location":"reference/parsers_sdf/#preconiters","text":"PreConIters ( self , default = 0 )","title":"PreConIters"},{"location":"reference/parsers_sdf/#precision","text":"Precision ( self )","title":"Precision"},{"location":"reference/parsers_sdf/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"reference/parsers_sdf/#quadratic","text":"Quadratic ( self , default = 0 )","title":"Quadratic"},{"location":"reference/parsers_sdf/#radius","text":"Radius ( self , default = 0 )","title":"Radius"},{"location":"reference/parsers_sdf/#range","text":"Range ( self )","title":"Range"},{"location":"reference/parsers_sdf/#rate","text":"Rate ( self , type = 'none' )","title":"Rate"},{"location":"reference/parsers_sdf/#ray","text":"Ray ( self )","title":"Ray"},{"location":"reference/parsers_sdf/#realtimefactor","text":"RealTimeFactor ( self , default = 1 )","title":"RealTimeFactor"},{"location":"reference/parsers_sdf/#realtimeupdaterate","text":"RealTimeUpdateRate ( self , default = 1 )","title":"RealTimeUpdateRate"},{"location":"reference/parsers_sdf/#resolution","text":"Resolution ( self , default = 0 )","title":"Resolution"},{"location":"reference/parsers_sdf/#restitutioncoefficient","text":"RestitutionCoefficient ( self , default = 0 )","title":"RestitutionCoefficient"},{"location":"reference/parsers_sdf/#rollingfriction","text":"RollingFriction ( self , default = 1 )","title":"RollingFriction"},{"location":"reference/parsers_sdf/#sdf","text":"SDF ( self , mode = 'world' )","title":"SDF"},{"location":"reference/parsers_sdf/#samples","text":"Samples ( self , default = 640 )","title":"Samples"},{"location":"reference/parsers_sdf/#save","text":"Save ( self )","title":"Save"},{"location":"reference/parsers_sdf/#scale","text":"Scale ( self , size = 3 )","title":"Scale"},{"location":"reference/parsers_sdf/#scan","text":"Scan ( self )","title":"Scan"},{"location":"reference/parsers_sdf/#scene","text":"Scene ( self )","title":"Scene"},{"location":"reference/parsers_sdf/#script","text":"Script ( self , mode = 'material' )","title":"Script"},{"location":"reference/parsers_sdf/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"reference/parsers_sdf/#sensor","text":"Sensor ( self , mode = 'altimeter' )","title":"Sensor"},{"location":"reference/parsers_sdf/#shader","text":"Shader ( self )","title":"Shader"},{"location":"reference/parsers_sdf/#shadows","text":"Shadows ( self , default = True )","title":"Shadows"},{"location":"reference/parsers_sdf/#simbody","text":"Simbody ( self , mode = 'physics' )","title":"Simbody"},{"location":"reference/parsers_sdf/#size","text":"Size ( self , vec_length = 3 )","title":"Size"},{"location":"reference/parsers_sdf/#skin","text":"Skin ( self )","title":"Skin"},{"location":"reference/parsers_sdf/#sky","text":"Sky ( self )","title":"Sky"},{"location":"reference/parsers_sdf/#slip","text":"Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip"},{"location":"reference/parsers_sdf/#slip1","text":"Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip1"},{"location":"reference/parsers_sdf/#slip2","text":"Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip2"},{"location":"reference/parsers_sdf/#softcfm","text":"SoftCFM ( self , default = 0 )","title":"SoftCFM"},{"location":"reference/parsers_sdf/#softerp","text":"SoftERP ( self , default = 0.2 )","title":"SoftERP"},{"location":"reference/parsers_sdf/#solver","text":"Solver ( self , engine = 'ode' )","title":"Solver"},{"location":"reference/parsers_sdf/#sor","text":"Sor ( self , default = 1.3 )","title":"Sor"},{"location":"reference/parsers_sdf/#specular","text":"Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ])","title":"Specular"},{"location":"reference/parsers_sdf/#speed","text":"Speed ( self , default = 0.6 )","title":"Speed"},{"location":"reference/parsers_sdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"reference/parsers_sdf/#splitimpulse","text":"SplitImpulse ( self , default = True )","title":"SplitImpulse"},{"location":"reference/parsers_sdf/#splitimpulsepenetrationthreshold","text":"SplitImpulsePenetrationThreshold ( self , default =- 0.01 )","title":"SplitImpulsePenetrationThreshold"},{"location":"reference/parsers_sdf/#spot","text":"Spot ( self )","title":"Spot"},{"location":"reference/parsers_sdf/#springreference","text":"SpringReference ( self , default = 0 )","title":"SpringReference"},{"location":"reference/parsers_sdf/#springstiffness","text":"SpringStiffness ( self , default = 0 )","title":"SpringStiffness"},{"location":"reference/parsers_sdf/#start","text":"Start ( self , default = 0 )","title":"Start"},{"location":"reference/parsers_sdf/#static","text":"Static ( self , default = False )","title":"Static"},{"location":"reference/parsers_sdf/#staticfriction","text":"StaticFriction ( self , default = 0.9 )","title":"StaticFriction"},{"location":"reference/parsers_sdf/#stddev_1","text":"StdDev ( self )","title":"StdDev"},{"location":"reference/parsers_sdf/#stiffness","text":"Stiffness ( self , default = 100000000.0 )","title":"Stiffness"},{"location":"reference/parsers_sdf/#submesh","text":"SubMesh ( self )","title":"SubMesh"},{"location":"reference/parsers_sdf/#sunrise","text":"Sunrise ( self , default = 0 )","title":"Sunrise"},{"location":"reference/parsers_sdf/#sunset","text":"Sunset ( self , default = 0 )","title":"Sunset"},{"location":"reference/parsers_sdf/#surface","text":"Surface ( self )","title":"Surface"},{"location":"reference/parsers_sdf/#surfaceradius","text":"SurfaceRadius ( self , default = 0 )","title":"SurfaceRadius"},{"location":"reference/parsers_sdf/#threshold","text":"Threshold ( self , default = 0 )","title":"Threshold"},{"location":"reference/parsers_sdf/#time","text":"Time ( self , default = 0 )","title":"Time"},{"location":"reference/parsers_sdf/#topic","text":"Topic ( self , default = 'none' )","title":"Topic"},{"location":"reference/parsers_sdf/#torsional","text":"Torsional ( self )","title":"Torsional"},{"location":"reference/parsers_sdf/#trackvisual","text":"TrackVisual ( self )","title":"TrackVisual"},{"location":"reference/parsers_sdf/#trajectory","text":"Trajectory ( self )","title":"Trajectory"},{"location":"reference/parsers_sdf/#transparency","text":"Transparency ( self , default = 0 )","title":"Transparency"},{"location":"reference/parsers_sdf/#type","text":"Type ( self , default = '' )","title":"Type"},{"location":"reference/parsers_sdf/#urdf","text":"URDF ( self , mode = 'model' )","title":"URDF"},{"location":"reference/parsers_sdf/#uri","text":"URI ( self , default = '' )","title":"URI"},{"location":"reference/parsers_sdf/#updaterate","text":"UpdateRate ( self , default = 0 )","title":"UpdateRate"},{"location":"reference/parsers_sdf/#upper","text":"Upper ( self , default = 1e+16 )","title":"Upper"},{"location":"reference/parsers_sdf/#usedynamicmoirescaling","text":"UseDynamicMOIRescaling ( self , default = False )","title":"UseDynamicMOIRescaling"},{"location":"reference/parsers_sdf/#usemodelframe","text":"UseModelFrame ( self , default = False )","title":"UseModelFrame"},{"location":"reference/parsers_sdf/#useparentmodelframe","text":"UseParentModelFrame ( self , default = False )","title":"UseParentModelFrame"},{"location":"reference/parsers_sdf/#usepatchradius","text":"UsePatchRadius ( self , default = True )","title":"UsePatchRadius"},{"location":"reference/parsers_sdf/#velocity","text":"Velocity ( self , default =- 1 )","title":"Velocity"},{"location":"reference/parsers_sdf/#vertical","text":"Vertical ( self )","title":"Vertical"},{"location":"reference/parsers_sdf/#verticalposition","text":"VerticalPosition ( self )","title":"VerticalPosition"},{"location":"reference/parsers_sdf/#verticalvelocity","text":"VerticalVelocity ( self )","title":"VerticalVelocity"},{"location":"reference/parsers_sdf/#viewcontroller","text":"ViewController ( self , default = 'orbit' )","title":"ViewController"},{"location":"reference/parsers_sdf/#viscousfriction","text":"ViscousFriction ( self , default = 0 )","title":"ViscousFriction"},{"location":"reference/parsers_sdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"reference/parsers_sdf/#visualize","text":"Visualize ( self , default = False )","title":"Visualize"},{"location":"reference/parsers_sdf/#waypoint","text":"Waypoint ( self )","title":"Waypoint"},{"location":"reference/parsers_sdf/#width","text":"Width ( self , default = 320 )","title":"Width"},{"location":"reference/parsers_sdf/#world","text":"World ( self )","title":"World"},{"location":"reference/parsers_sdf/#x","text":"X ( self )","title":"X"},{"location":"reference/parsers_sdf/#xyz","text":"XYZ ( self , default = [ 0 , 0 , 1 ])","title":"XYZ"},{"location":"reference/parsers_sdf/#y","text":"Y ( self )","title":"Y"},{"location":"reference/parsers_sdf/#z","text":"Z ( self )","title":"Z"},{"location":"reference/parsers_sdf_config/","text":"pcg_gazebo.parsers.sdf_config \u00b6 Author \u00b6 Author ( self ) Description \u00b6 Description ( self , default = 'none' ) EMail \u00b6 EMail ( self , default = 'none' ) Model \u00b6 Model ( self ) Name \u00b6 Name ( self , default = 'none' ) SDF \u00b6 SDF ( self , default = 'model.sdf' ) Version \u00b6 Version ( self , default = 'none' )","title":"pcg_gazebo.parsers.sdf_config"},{"location":"reference/parsers_sdf_config/#pcg_gazeboparserssdf_config","text":"","title":"pcg_gazebo.parsers.sdf_config"},{"location":"reference/parsers_sdf_config/#author","text":"Author ( self )","title":"Author"},{"location":"reference/parsers_sdf_config/#description","text":"Description ( self , default = 'none' )","title":"Description"},{"location":"reference/parsers_sdf_config/#email","text":"EMail ( self , default = 'none' )","title":"EMail"},{"location":"reference/parsers_sdf_config/#model","text":"Model ( self )","title":"Model"},{"location":"reference/parsers_sdf_config/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"reference/parsers_sdf_config/#sdf","text":"SDF ( self , default = 'model.sdf' )","title":"SDF"},{"location":"reference/parsers_sdf_config/#version","text":"Version ( self , default = 'none' )","title":"Version"},{"location":"reference/parsers_types/","text":"pcg_gazebo.parsers.types \u00b6 XMLBase \u00b6 XMLBase ( self ) attributes \u00b6 dict : XML properties xml_element_name \u00b6 str : Name of the SDF element xml_format \u00b6 str : Name of the XML format XMLBoolean \u00b6 XMLBoolean ( self , default = False ) XMLCustom \u00b6 XMLCustom ( self , default = {}) XMLInteger \u00b6 XMLInteger ( self , default = 0 , min_value = None , max_value = None ) XMLScalar \u00b6 XMLScalar ( self , default = 0 , min_value = None , max_value = None ) XMLString \u00b6 XMLString ( self , default = '' ) XMLVector \u00b6 XMLVector ( self , size = None )","title":"pcg_gazebo.parsers.types"},{"location":"reference/parsers_types/#pcg_gazeboparserstypes","text":"","title":"pcg_gazebo.parsers.types"},{"location":"reference/parsers_types/#xmlbase","text":"XMLBase ( self )","title":"XMLBase"},{"location":"reference/parsers_types/#attributes","text":"dict : XML properties","title":"attributes"},{"location":"reference/parsers_types/#xml_element_name","text":"str : Name of the SDF element","title":"xml_element_name"},{"location":"reference/parsers_types/#xml_format","text":"str : Name of the XML format","title":"xml_format"},{"location":"reference/parsers_types/#xmlboolean","text":"XMLBoolean ( self , default = False )","title":"XMLBoolean"},{"location":"reference/parsers_types/#xmlcustom","text":"XMLCustom ( self , default = {})","title":"XMLCustom"},{"location":"reference/parsers_types/#xmlinteger","text":"XMLInteger ( self , default = 0 , min_value = None , max_value = None )","title":"XMLInteger"},{"location":"reference/parsers_types/#xmlscalar","text":"XMLScalar ( self , default = 0 , min_value = None , max_value = None )","title":"XMLScalar"},{"location":"reference/parsers_types/#xmlstring","text":"XMLString ( self , default = '' )","title":"XMLString"},{"location":"reference/parsers_types/#xmlvector","text":"XMLVector ( self , size = None )","title":"XMLVector"},{"location":"reference/parsers_urdf/","text":"pcg_gazebo.parsers.urdf \u00b6 get_all_urdf_element_classes \u00b6 get_all_urdf_element_classes () Get list of all URDF element classes. create_urdf_element \u00b6 create_urdf_element ( tag , * args ) URDF element factory. Input arguments tag ( type: str ): Name of the URDF element. args : Extra arguments for URDF element constructor. Returns URDF element if tag refers to a valid URDF element. None , otherwise. create_urdf_type \u00b6 create_urdf_type ( tag ) Return handle of the URDF element type. Input arguments tag ( type: str ): Name of the URDF element. Returns URDF element type if tag is valid, None otherwise`. is_urdf_element \u00b6 is_urdf_element ( obj ) Test if XML element is an URDF element. Actuator \u00b6 Actuator ( self ) Axis \u00b6 Axis ( self , default = [ 1 , 0 , 0 ]) Box \u00b6 Box ( self ) Child \u00b6 Child ( self , default = 'link' ) Collision \u00b6 Collision ( self ) Color \u00b6 Color ( self , default = [ 0 , 0 , 0 , 1 ]) Cylinder \u00b6 Cylinder ( self ) Dynamics \u00b6 Dynamics ( self ) Gazebo \u00b6 Gazebo ( self , mode = 'none' , sdf_elements = {}) Geometry \u00b6 Geometry ( self ) HardwareInterface \u00b6 HardwareInterface ( self , default = 'EffortJointInterface' ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) Joint \u00b6 Joint ( self ) Kd \u00b6 Kd ( self , default = 1 ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) Limit \u00b6 Limit ( self ) Link \u00b6 Link ( self ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self , mode = 'color' ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) MechanicalReduction \u00b6 MechanicalReduction ( self , default = 1 ) Mesh \u00b6 Mesh ( self ) Mimic \u00b6 Mimic ( self ) MinDepth \u00b6 MinDepth ( self , default = 0 ) Mu1 \u00b6 Mu1 ( self , default = 1 ) Mu2 \u00b6 Mu2 ( self , default = 1 ) Origin \u00b6 Origin ( self ) Parent \u00b6 Parent ( self , default = 'link' ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) Robot \u00b6 Robot ( self ) SafetyController \u00b6 SafetyController ( self ) SelfCollide \u00b6 SelfCollide ( self , default = False ) Sphere \u00b6 Sphere ( self ) StopCFM \u00b6 StopCFM ( self , default = 0 ) StopERP \u00b6 StopERP ( self , default = 0.2 ) Texture \u00b6 Texture ( self , default = 'filename' ) Transmission \u00b6 Transmission ( self ) Type \u00b6 Type ( self , default = 'transmission_interface/SimpleTransmission' ) Visual \u00b6 Visual ( self )","title":"pcg_gazebo.parsers.urdf"},{"location":"reference/parsers_urdf/#pcg_gazeboparsersurdf","text":"","title":"pcg_gazebo.parsers.urdf"},{"location":"reference/parsers_urdf/#get_all_urdf_element_classes","text":"get_all_urdf_element_classes () Get list of all URDF element classes.","title":"get_all_urdf_element_classes"},{"location":"reference/parsers_urdf/#create_urdf_element","text":"create_urdf_element ( tag , * args ) URDF element factory. Input arguments tag ( type: str ): Name of the URDF element. args : Extra arguments for URDF element constructor. Returns URDF element if tag refers to a valid URDF element. None , otherwise.","title":"create_urdf_element"},{"location":"reference/parsers_urdf/#create_urdf_type","text":"create_urdf_type ( tag ) Return handle of the URDF element type. Input arguments tag ( type: str ): Name of the URDF element. Returns URDF element type if tag is valid, None otherwise`.","title":"create_urdf_type"},{"location":"reference/parsers_urdf/#is_urdf_element","text":"is_urdf_element ( obj ) Test if XML element is an URDF element.","title":"is_urdf_element"},{"location":"reference/parsers_urdf/#actuator","text":"Actuator ( self )","title":"Actuator"},{"location":"reference/parsers_urdf/#axis","text":"Axis ( self , default = [ 1 , 0 , 0 ])","title":"Axis"},{"location":"reference/parsers_urdf/#box","text":"Box ( self )","title":"Box"},{"location":"reference/parsers_urdf/#child","text":"Child ( self , default = 'link' )","title":"Child"},{"location":"reference/parsers_urdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"reference/parsers_urdf/#color","text":"Color ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Color"},{"location":"reference/parsers_urdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"reference/parsers_urdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"reference/parsers_urdf/#gazebo","text":"Gazebo ( self , mode = 'none' , sdf_elements = {})","title":"Gazebo"},{"location":"reference/parsers_urdf/#geometry","text":"Geometry ( self )","title":"Geometry"},{"location":"reference/parsers_urdf/#hardwareinterface","text":"HardwareInterface ( self , default = 'EffortJointInterface' )","title":"HardwareInterface"},{"location":"reference/parsers_urdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"reference/parsers_urdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"reference/parsers_urdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"reference/parsers_urdf/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"reference/parsers_urdf/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"reference/parsers_urdf/#limit","text":"Limit ( self )","title":"Limit"},{"location":"reference/parsers_urdf/#link","text":"Link ( self )","title":"Link"},{"location":"reference/parsers_urdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"reference/parsers_urdf/#material","text":"Material ( self , mode = 'color' )","title":"Material"},{"location":"reference/parsers_urdf/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"reference/parsers_urdf/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"reference/parsers_urdf/#mechanicalreduction","text":"MechanicalReduction ( self , default = 1 )","title":"MechanicalReduction"},{"location":"reference/parsers_urdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"reference/parsers_urdf/#mimic","text":"Mimic ( self )","title":"Mimic"},{"location":"reference/parsers_urdf/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"reference/parsers_urdf/#mu1","text":"Mu1 ( self , default = 1 )","title":"Mu1"},{"location":"reference/parsers_urdf/#mu2","text":"Mu2 ( self , default = 1 )","title":"Mu2"},{"location":"reference/parsers_urdf/#origin","text":"Origin ( self )","title":"Origin"},{"location":"reference/parsers_urdf/#parent","text":"Parent ( self , default = 'link' )","title":"Parent"},{"location":"reference/parsers_urdf/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"reference/parsers_urdf/#robot","text":"Robot ( self )","title":"Robot"},{"location":"reference/parsers_urdf/#safetycontroller","text":"SafetyController ( self )","title":"SafetyController"},{"location":"reference/parsers_urdf/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"reference/parsers_urdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"reference/parsers_urdf/#stopcfm","text":"StopCFM ( self , default = 0 )","title":"StopCFM"},{"location":"reference/parsers_urdf/#stoperp","text":"StopERP ( self , default = 0.2 )","title":"StopERP"},{"location":"reference/parsers_urdf/#texture","text":"Texture ( self , default = 'filename' )","title":"Texture"},{"location":"reference/parsers_urdf/#transmission","text":"Transmission ( self )","title":"Transmission"},{"location":"reference/parsers_urdf/#type","text":"Type ( self , default = 'transmission_interface/SimpleTransmission' )","title":"Type"},{"location":"reference/parsers_urdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"reference/path/","text":"pcg_gazebo.path \u00b6 Path \u00b6 Path ( self , uri ) Path resolver for ROS and Gazebo model paths. The paths can be resolved if provided as: Absolute path $(find ros_pkg) package:// model:// file:// Input arguments uri ( type: str ): Input path to be resolved. is_valid \u00b6 bool : True if the absolute URI exists. original_uri \u00b6 str : Original URI provided.","title":"pcg_gazebo.path"},{"location":"reference/path/#pcg_gazebopath","text":"","title":"pcg_gazebo.path"},{"location":"reference/path/#path","text":"Path ( self , uri ) Path resolver for ROS and Gazebo model paths. The paths can be resolved if provided as: Absolute path $(find ros_pkg) package:// model:// file:// Input arguments uri ( type: str ): Input path to be resolved.","title":"Path"},{"location":"reference/path/#is_valid","text":"bool : True if the absolute URI exists.","title":"is_valid"},{"location":"reference/path/#original_uri","text":"str : Original URI provided.","title":"original_uri"},{"location":"reference/simulation/","text":"pcg_gazebo.simulation \u00b6 Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo. create_object \u00b6 create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance. get_gazebo_model_folders \u00b6 get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names. load_gazebo_models \u00b6 load_gazebo_models () Search for Gazebo models in the local .gazebo/models folder and in the ROS paths. Returns dict : Information of all Gazebo models found get_gazebo_models \u00b6 get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo/models folder and in the catkin workspace as a dictionary. get_gazebo_model_names \u00b6 get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo/models folders and catkin workspace. get_gazebo_model_ros_pkg \u00b6 get_gazebo_model_ros_pkg ( name ) Return name of the ROS package where the Gazebo model is located, None if it was found in .gazebo/models. is_gazebo_model \u00b6 is_gazebo_model ( name ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model. get_gazebo_model_path \u00b6 get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder get_gazebo_model_sdf \u00b6 get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model.sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo.parsers.types.XMLBase instance as an SDF element. Box \u00b6 Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo.simulation.Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [1, 1, 1] ): Vector with width, length and height of the box, collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single box-shaped collision model. size \u00b6 List of float : Size of the box as [width, length, height] visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single box-shaped visual model. to_sdf \u00b6 Box . to_sdf ( self , type = 'model' , name = 'box' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial \u00b6 Box . add_inertial ( self , mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_inertial \u00b6 Box . update_inertial ( self , mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Box . update_collision ( self ) Update collision model according to the current size . update_visual \u00b6 Box . update_visual ( self ) Update visual model according to the current size . Cylinder \u00b6 Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters. collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single cylinder-shaped collision model. length \u00b6 float : Length of the cylinder in meters radius \u00b6 float : Radius of the cylinder in meters visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single cylinder-shaped visual model. to_sdf \u00b6 Cylinder . to_sdf ( self , type = 'model' , name = 'cylinder' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. update_inertial \u00b6 Cylinder . update_inertial ( self , mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Cylinder . update_collision ( self ) Update collision model according to the current length and radius . update_visual \u00b6 Cylinder . update_visual ( self ) Update visual model according to the current length and radius . Joint \u00b6 Joint ( self , name = 'joint' , parent = None , child = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 , use_parent_model_frame = False ) Light \u00b6 Light ( self , name = 'default' , type = 'point' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , inner_angle = None , outer_angle = None , falloff = None ) Link \u00b6 Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ). collisions \u00b6 List of pcg_gazebo.simulation.properties.Collision : List of collision models creation_time \u00b6 float : Time of creation of this object, if it represents a single-link model. inertial \u00b6 pcg_gazebo.simulation.properties.Inertial : Description of the object's moments of inertia. kinematic \u00b6 bool : Flag to indicate if the model is purely kinematic life_timeout \u00b6 float : Life timeout timestamp for this object, if it represents a single-link model name \u00b6 str : Object name pose \u00b6 pcg_gazebo.simulation.properties.Pose : Pose of the object self_collide \u00b6 bool : Self-collision flag static \u00b6 bool : Flag to indicate if object is static visuals \u00b6 List of pcg_gazebo.simulation.properties.Visual : List of visual models create_link_from_mesh \u00b6 Link . create_link_from_mesh ( name = 'link' , visual_mesh = None , collision_mesh = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' , visual_parameters = {}, collision_parameters = {}) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the visual mesh file or a mesh object. collision_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [0, 0, 0, 0, 0, 0] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict(ixx=0, iyy=0, izz=0, ixy=0, ixz=0, iyz=0) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo.simulation.Link instance. enable_collision \u00b6 Link . enable_collision ( self ) Enable the inclusion of the collision models in the exported SDF description. disable_collision \u00b6 Link . disable_collision ( self ) Disable the inclusion of the collision models in the exported SDF description. enable_visual \u00b6 Link . enable_visual ( self ) Enable the inclusion of the visual models in the exported SDF description. disable_visual \u00b6 Link . disable_visual ( self ) Disable the inclusion of the collision models in the exported SDF description. get_collision_by_name \u00b6 Link . get_collision_by_name ( self , name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo.simulation.properties.Collision , or None if not collision with the given name is found. has_collision \u00b6 Link . has_collision ( self , name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise. get_visual_by_name \u00b6 Link . get_visual_by_name ( self , name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo.simulation.properties.Visual , or None if not visual with the given name is found. has_visual \u00b6 Link . has_visual ( self , name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise. add_empty_visual \u00b6 Link . add_empty_visual ( self , name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists. add_visual \u00b6 Link . add_visual ( self , visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo.simulation.properties.Visual ): Visual element Returns bool : True , if visual element could be added to object. add_empty_collision \u00b6 Link . add_empty_collision ( self , name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists. add_collision \u00b6 Link . add_collision ( self , collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo.simulation.properties.Collision ): Collision element Returns bool : True , if collision element could be added to object. to_sdf \u00b6 Link . to_sdf ( self , type = 'link' , name = 'model' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. from_sdf \u00b6 Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo.simulation.Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.Link ): SDF object Returns pcg_gazebo.simulation.Link : Simulation object instance export_to_gazebo_model \u00b6 Link . export_to_gazebo_model ( self , output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir/ model.sdf model.config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1.6 ): Version of the SDF format version ( type: str , default: 0.1.0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully. add_inertial \u00b6 Link . add_inertial ( self , mass ) This function must be implemented by derived classes. update_inertial \u00b6 Link . update_inertial ( self ) This function must be implemented by derived classes. update_collision \u00b6 Link . update_collision ( self ) This function must be implemented by derived classes. update_visual \u00b6 Link . update_visual ( self ) This function must be implemented by derived classes. add_sensor \u00b6 Link . add_sensor ( self , name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo.simulation.sensors.Sensor ): Sensor description Returns bool : True , if sensor could be added to link. to_markers \u00b6 Link . to_markers ( self ) Generate visualization_msgs/Marker instances from the visual and/or collision entities. Returns visualization_msgs/MarkerArray get_footprint \u00b6 Link . get_footprint ( self , mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon get_meshes \u00b6 Link . get_meshes ( self , mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes. get_bounds \u00b6 Link . get_bounds ( self , mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds ModelGroup \u00b6 ModelGroup ( self , name = 'group' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], is_ground_plane = False ) lights \u00b6 dict : Lights models \u00b6 dict : Models n_lights \u00b6 int : Number of lights n_models \u00b6 int : Number of models reset_models \u00b6 ModelGroup . reset_models ( self ) Reset the list of models. add_model \u00b6 ModelGroup . add_model ( self , tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model \u00b6 ModelGroup . rm_model ( self , tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists \u00b6 ModelGroup . model_exists ( self , tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_include \u00b6 ModelGroup . add_include ( self , include ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_light \u00b6 ModelGroup . add_light ( self , tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light \u00b6 ModelGroup . rm_light ( self , tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists \u00b6 ModelGroup . light_exists ( self , tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. Plane \u00b6 Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ]) Polyline \u00b6 Polyline ( self , name = 'polyline' , height = 1 , points = []) SimulationModel \u00b6 SimulationModel ( self , name = 'model' , parent = 'world' , creation_time = None , life_timeout = None , is_ground_plane = False ) Sphere \u00b6 Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single sphere-shaped collision model. radius \u00b6 float : Radius of the sphere in meters visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single sphere-shaped visual model. to_sdf \u00b6 Sphere . to_sdf ( self , type = 'model' , name = 'sphere' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial \u00b6 Sphere . add_inertial ( self , mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one update_inertial \u00b6 Sphere . update_inertial ( self , mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Sphere . update_collision ( self ) Update collision model according to the current radius . update_visual \u00b6 Sphere . update_visual ( self ) Update visual model according to the current radius . World \u00b6 World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [0, 0, -9.8] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody . engine \u00b6 str : Name identifier of the physics engine gravity \u00b6 list : Acceleration of gravity vector lights \u00b6 dict : Lights model_groups \u00b6 dict : Model groups models \u00b6 dict : Models name \u00b6 str : Name of the world physics \u00b6 pcg_gazebo.simulation.physics.Physics : Physics engine instance reset_physics \u00b6 World . reset_physics ( self , engine = 'ode' , * args , ** kwargs ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody . reset_models \u00b6 World . reset_models ( self ) Reset the list of models. add_include \u00b6 World . add_include ( self , include , group = 'default' ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_model \u00b6 World . add_model ( self , tag , model , group = 'default' ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model \u00b6 World . rm_model ( self , tag , group = 'default' ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists \u00b6 World . model_exists ( self , tag , group = None ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_plugin \u00b6 World . add_plugin ( self , tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo.parsers.sdf.Plugin or pcg_gazebo.simulation.properties.Plugin ): Plugin description. rm_plugin \u00b6 World . rm_plugin ( self , tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world. plugin_exists \u00b6 World . plugin_exists ( self , tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise. add_light \u00b6 World . add_light ( self , tag , light , group = 'default' ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light \u00b6 World . rm_light ( self , tag , group = 'default' ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists \u00b6 World . light_exists ( self , tag , group = 'default' ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. to_sdf \u00b6 World . to_sdf ( self , type = 'world' , with_default_ground_plane = True , with_default_sun = True ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo.parsers.sdf.SDF with a world element in it or pcg_gazebo.parsers.sdf.World . from_sdf \u00b6 World . from_sdf ( sdf ) Parse an pcg_gazebo.parsers.sdf.World into a World class. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.World ): SDF world element Returns pcg_gazebo.parsers.sdf.World instance. create_scene \u00b6 World . create_scene ( self , mesh_type = 'collision' , add_pseudo_color = True ) Return a trimesh.Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color. plot_footprints \u00b6 World . plot_footprints ( self , fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib.pyplot.Figure or bokeh.plotting.Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib.pyplot.Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0.5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib.pyplot.Figure or bokeh.plotting.Figure .","title":"pcg_gazebo.simulation"},{"location":"reference/simulation/#pcg_gazebosimulation","text":"Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo.","title":"pcg_gazebo.simulation"},{"location":"reference/simulation/#create_object","text":"create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance.","title":"create_object"},{"location":"reference/simulation/#get_gazebo_model_folders","text":"get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names.","title":"get_gazebo_model_folders"},{"location":"reference/simulation/#load_gazebo_models","text":"load_gazebo_models () Search for Gazebo models in the local .gazebo/models folder and in the ROS paths. Returns dict : Information of all Gazebo models found","title":"load_gazebo_models"},{"location":"reference/simulation/#get_gazebo_models","text":"get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo/models folder and in the catkin workspace as a dictionary.","title":"get_gazebo_models"},{"location":"reference/simulation/#get_gazebo_model_names","text":"get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo/models folders and catkin workspace.","title":"get_gazebo_model_names"},{"location":"reference/simulation/#get_gazebo_model_ros_pkg","text":"get_gazebo_model_ros_pkg ( name ) Return name of the ROS package where the Gazebo model is located, None if it was found in .gazebo/models.","title":"get_gazebo_model_ros_pkg"},{"location":"reference/simulation/#is_gazebo_model","text":"is_gazebo_model ( name ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model.","title":"is_gazebo_model"},{"location":"reference/simulation/#get_gazebo_model_path","text":"get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder","title":"get_gazebo_model_path"},{"location":"reference/simulation/#get_gazebo_model_sdf","text":"get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model.sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo.parsers.types.XMLBase instance as an SDF element.","title":"get_gazebo_model_sdf"},{"location":"reference/simulation/#box","text":"Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo.simulation.Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [1, 1, 1] ): Vector with width, length and height of the box,","title":"Box"},{"location":"reference/simulation/#collision","text":"pcg_gazebo.simulation.properties.Collision : Return single box-shaped collision model.","title":"collision"},{"location":"reference/simulation/#size","text":"List of float : Size of the box as [width, length, height]","title":"size"},{"location":"reference/simulation/#visual","text":"pcg_gazebo.simulation.properties.Visual : Return single box-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf","text":"Box . to_sdf ( self , type = 'model' , name = 'box' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#add_inertial","text":"Box . add_inertial ( self , mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"add_inertial"},{"location":"reference/simulation/#update_inertial","text":"Box . update_inertial ( self , mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision","text":"Box . update_collision ( self ) Update collision model according to the current size .","title":"update_collision"},{"location":"reference/simulation/#update_visual","text":"Box . update_visual ( self ) Update visual model according to the current size .","title":"update_visual"},{"location":"reference/simulation/#cylinder","text":"Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters.","title":"Cylinder"},{"location":"reference/simulation/#collision_1","text":"pcg_gazebo.simulation.properties.Collision : Return single cylinder-shaped collision model.","title":"collision"},{"location":"reference/simulation/#length","text":"float : Length of the cylinder in meters","title":"length"},{"location":"reference/simulation/#radius","text":"float : Radius of the cylinder in meters","title":"radius"},{"location":"reference/simulation/#visual_1","text":"pcg_gazebo.simulation.properties.Visual : Return single cylinder-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf_1","text":"Cylinder . to_sdf ( self , type = 'model' , name = 'cylinder' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#update_inertial_1","text":"Cylinder . update_inertial ( self , mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision_1","text":"Cylinder . update_collision ( self ) Update collision model according to the current length and radius .","title":"update_collision"},{"location":"reference/simulation/#update_visual_1","text":"Cylinder . update_visual ( self ) Update visual model according to the current length and radius .","title":"update_visual"},{"location":"reference/simulation/#joint","text":"Joint ( self , name = 'joint' , parent = None , child = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 , use_parent_model_frame = False )","title":"Joint"},{"location":"reference/simulation/#light","text":"Light ( self , name = 'default' , type = 'point' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , inner_angle = None , outer_angle = None , falloff = None )","title":"Light"},{"location":"reference/simulation/#link","text":"Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ).","title":"Link"},{"location":"reference/simulation/#collisions","text":"List of pcg_gazebo.simulation.properties.Collision : List of collision models","title":"collisions"},{"location":"reference/simulation/#creation_time","text":"float : Time of creation of this object, if it represents a single-link model.","title":"creation_time"},{"location":"reference/simulation/#inertial","text":"pcg_gazebo.simulation.properties.Inertial : Description of the object's moments of inertia.","title":"inertial"},{"location":"reference/simulation/#kinematic","text":"bool : Flag to indicate if the model is purely kinematic","title":"kinematic"},{"location":"reference/simulation/#life_timeout","text":"float : Life timeout timestamp for this object, if it represents a single-link model","title":"life_timeout"},{"location":"reference/simulation/#name","text":"str : Object name","title":"name"},{"location":"reference/simulation/#pose","text":"pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pose"},{"location":"reference/simulation/#self_collide","text":"bool : Self-collision flag","title":"self_collide"},{"location":"reference/simulation/#static","text":"bool : Flag to indicate if object is static","title":"static"},{"location":"reference/simulation/#visuals","text":"List of pcg_gazebo.simulation.properties.Visual : List of visual models","title":"visuals"},{"location":"reference/simulation/#create_link_from_mesh","text":"Link . create_link_from_mesh ( name = 'link' , visual_mesh = None , collision_mesh = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' , visual_parameters = {}, collision_parameters = {}) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the visual mesh file or a mesh object. collision_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [0, 0, 0, 0, 0, 0] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict(ixx=0, iyy=0, izz=0, ixy=0, ixz=0, iyz=0) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo.simulation.Link instance.","title":"create_link_from_mesh"},{"location":"reference/simulation/#enable_collision","text":"Link . enable_collision ( self ) Enable the inclusion of the collision models in the exported SDF description.","title":"enable_collision"},{"location":"reference/simulation/#disable_collision","text":"Link . disable_collision ( self ) Disable the inclusion of the collision models in the exported SDF description.","title":"disable_collision"},{"location":"reference/simulation/#enable_visual","text":"Link . enable_visual ( self ) Enable the inclusion of the visual models in the exported SDF description.","title":"enable_visual"},{"location":"reference/simulation/#disable_visual","text":"Link . disable_visual ( self ) Disable the inclusion of the collision models in the exported SDF description.","title":"disable_visual"},{"location":"reference/simulation/#get_collision_by_name","text":"Link . get_collision_by_name ( self , name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo.simulation.properties.Collision , or None if not collision with the given name is found.","title":"get_collision_by_name"},{"location":"reference/simulation/#has_collision","text":"Link . has_collision ( self , name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise.","title":"has_collision"},{"location":"reference/simulation/#get_visual_by_name","text":"Link . get_visual_by_name ( self , name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo.simulation.properties.Visual , or None if not visual with the given name is found.","title":"get_visual_by_name"},{"location":"reference/simulation/#has_visual","text":"Link . has_visual ( self , name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise.","title":"has_visual"},{"location":"reference/simulation/#add_empty_visual","text":"Link . add_empty_visual ( self , name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists.","title":"add_empty_visual"},{"location":"reference/simulation/#add_visual","text":"Link . add_visual ( self , visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo.simulation.properties.Visual ): Visual element Returns bool : True , if visual element could be added to object.","title":"add_visual"},{"location":"reference/simulation/#add_empty_collision","text":"Link . add_empty_collision ( self , name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists.","title":"add_empty_collision"},{"location":"reference/simulation/#add_collision","text":"Link . add_collision ( self , collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo.simulation.properties.Collision ): Collision element Returns bool : True , if collision element could be added to object.","title":"add_collision"},{"location":"reference/simulation/#to_sdf_2","text":"Link . to_sdf ( self , type = 'link' , name = 'model' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#from_sdf","text":"Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo.simulation.Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.Link ): SDF object Returns pcg_gazebo.simulation.Link : Simulation object instance","title":"from_sdf"},{"location":"reference/simulation/#export_to_gazebo_model","text":"Link . export_to_gazebo_model ( self , output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir/ model.sdf model.config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1.6 ): Version of the SDF format version ( type: str , default: 0.1.0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully.","title":"export_to_gazebo_model"},{"location":"reference/simulation/#add_inertial_1","text":"Link . add_inertial ( self , mass ) This function must be implemented by derived classes.","title":"add_inertial"},{"location":"reference/simulation/#update_inertial_2","text":"Link . update_inertial ( self ) This function must be implemented by derived classes.","title":"update_inertial"},{"location":"reference/simulation/#update_collision_2","text":"Link . update_collision ( self ) This function must be implemented by derived classes.","title":"update_collision"},{"location":"reference/simulation/#update_visual_2","text":"Link . update_visual ( self ) This function must be implemented by derived classes.","title":"update_visual"},{"location":"reference/simulation/#add_sensor","text":"Link . add_sensor ( self , name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo.simulation.sensors.Sensor ): Sensor description Returns bool : True , if sensor could be added to link.","title":"add_sensor"},{"location":"reference/simulation/#to_markers","text":"Link . to_markers ( self ) Generate visualization_msgs/Marker instances from the visual and/or collision entities. Returns visualization_msgs/MarkerArray","title":"to_markers"},{"location":"reference/simulation/#get_footprint","text":"Link . get_footprint ( self , mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon","title":"get_footprint"},{"location":"reference/simulation/#get_meshes","text":"Link . get_meshes ( self , mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes.","title":"get_meshes"},{"location":"reference/simulation/#get_bounds","text":"Link . get_bounds ( self , mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds","title":"get_bounds"},{"location":"reference/simulation/#modelgroup","text":"ModelGroup ( self , name = 'group' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], is_ground_plane = False )","title":"ModelGroup"},{"location":"reference/simulation/#lights","text":"dict : Lights","title":"lights"},{"location":"reference/simulation/#models","text":"dict : Models","title":"models"},{"location":"reference/simulation/#n_lights","text":"int : Number of lights","title":"n_lights"},{"location":"reference/simulation/#n_models","text":"int : Number of models","title":"n_models"},{"location":"reference/simulation/#reset_models","text":"ModelGroup . reset_models ( self ) Reset the list of models.","title":"reset_models"},{"location":"reference/simulation/#add_model","text":"ModelGroup . add_model ( self , tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world.","title":"add_model"},{"location":"reference/simulation/#rm_model","text":"ModelGroup . rm_model ( self , tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world.","title":"rm_model"},{"location":"reference/simulation/#model_exists","text":"ModelGroup . model_exists ( self , tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise.","title":"model_exists"},{"location":"reference/simulation/#add_include","text":"ModelGroup . add_include ( self , include ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world.","title":"add_include"},{"location":"reference/simulation/#add_light","text":"ModelGroup . add_light ( self , tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description","title":"add_light"},{"location":"reference/simulation/#rm_light","text":"ModelGroup . rm_light ( self , tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world.","title":"rm_light"},{"location":"reference/simulation/#light_exists","text":"ModelGroup . light_exists ( self , tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise.","title":"light_exists"},{"location":"reference/simulation/#plane","text":"Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ])","title":"Plane"},{"location":"reference/simulation/#polyline","text":"Polyline ( self , name = 'polyline' , height = 1 , points = [])","title":"Polyline"},{"location":"reference/simulation/#simulationmodel","text":"SimulationModel ( self , name = 'model' , parent = 'world' , creation_time = None , life_timeout = None , is_ground_plane = False )","title":"SimulationModel"},{"location":"reference/simulation/#sphere","text":"Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters","title":"Sphere"},{"location":"reference/simulation/#collision_2","text":"pcg_gazebo.simulation.properties.Collision : Return single sphere-shaped collision model.","title":"collision"},{"location":"reference/simulation/#radius_1","text":"float : Radius of the sphere in meters","title":"radius"},{"location":"reference/simulation/#visual_2","text":"pcg_gazebo.simulation.properties.Visual : Return single sphere-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf_3","text":"Sphere . to_sdf ( self , type = 'model' , name = 'sphere' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#add_inertial_2","text":"Sphere . add_inertial ( self , mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one","title":"add_inertial"},{"location":"reference/simulation/#update_inertial_3","text":"Sphere . update_inertial ( self , mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision_3","text":"Sphere . update_collision ( self ) Update collision model according to the current radius .","title":"update_collision"},{"location":"reference/simulation/#update_visual_3","text":"Sphere . update_visual ( self ) Update visual model according to the current radius .","title":"update_visual"},{"location":"reference/simulation/#world","text":"World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [0, 0, -9.8] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody .","title":"World"},{"location":"reference/simulation/#engine","text":"str : Name identifier of the physics engine","title":"engine"},{"location":"reference/simulation/#gravity","text":"list : Acceleration of gravity vector","title":"gravity"},{"location":"reference/simulation/#lights_1","text":"dict : Lights","title":"lights"},{"location":"reference/simulation/#model_groups","text":"dict : Model groups","title":"model_groups"},{"location":"reference/simulation/#models_1","text":"dict : Models","title":"models"},{"location":"reference/simulation/#name_1","text":"str : Name of the world","title":"name"},{"location":"reference/simulation/#physics","text":"pcg_gazebo.simulation.physics.Physics : Physics engine instance","title":"physics"},{"location":"reference/simulation/#reset_physics","text":"World . reset_physics ( self , engine = 'ode' , * args , ** kwargs ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody .","title":"reset_physics"},{"location":"reference/simulation/#reset_models_1","text":"World . reset_models ( self ) Reset the list of models.","title":"reset_models"},{"location":"reference/simulation/#add_include_1","text":"World . add_include ( self , include , group = 'default' ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world.","title":"add_include"},{"location":"reference/simulation/#add_model_1","text":"World . add_model ( self , tag , model , group = 'default' ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world.","title":"add_model"},{"location":"reference/simulation/#rm_model_1","text":"World . rm_model ( self , tag , group = 'default' ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world.","title":"rm_model"},{"location":"reference/simulation/#model_exists_1","text":"World . model_exists ( self , tag , group = None ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise.","title":"model_exists"},{"location":"reference/simulation/#add_plugin","text":"World . add_plugin ( self , tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo.parsers.sdf.Plugin or pcg_gazebo.simulation.properties.Plugin ): Plugin description.","title":"add_plugin"},{"location":"reference/simulation/#rm_plugin","text":"World . rm_plugin ( self , tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world.","title":"rm_plugin"},{"location":"reference/simulation/#plugin_exists","text":"World . plugin_exists ( self , tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise.","title":"plugin_exists"},{"location":"reference/simulation/#add_light_1","text":"World . add_light ( self , tag , light , group = 'default' ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description","title":"add_light"},{"location":"reference/simulation/#rm_light_1","text":"World . rm_light ( self , tag , group = 'default' ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world.","title":"rm_light"},{"location":"reference/simulation/#light_exists_1","text":"World . light_exists ( self , tag , group = 'default' ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise.","title":"light_exists"},{"location":"reference/simulation/#to_sdf_4","text":"World . to_sdf ( self , type = 'world' , with_default_ground_plane = True , with_default_sun = True ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo.parsers.sdf.SDF with a world element in it or pcg_gazebo.parsers.sdf.World .","title":"to_sdf"},{"location":"reference/simulation/#from_sdf_1","text":"World . from_sdf ( sdf ) Parse an pcg_gazebo.parsers.sdf.World into a World class. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.World ): SDF world element Returns pcg_gazebo.parsers.sdf.World instance.","title":"from_sdf"},{"location":"reference/simulation/#create_scene","text":"World . create_scene ( self , mesh_type = 'collision' , add_pseudo_color = True ) Return a trimesh.Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color.","title":"create_scene"},{"location":"reference/simulation/#plot_footprints","text":"World . plot_footprints ( self , fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib.pyplot.Figure or bokeh.plotting.Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib.pyplot.Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0.5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib.pyplot.Figure or bokeh.plotting.Figure .","title":"plot_footprints"},{"location":"reference/simulation_physics/","text":"pcg_gazebo.simulation.physics \u00b6 Bullet \u00b6 Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = True , split_impulse_penetration_threshold =- 0.01 ) ODE \u00b6 ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_rescaling = False , friction_model = 'pyramid_model' , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , contact_max_correcting_vel = 100 ) Physics \u00b6 Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False ) Simbody \u00b6 Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 0.5 , static_friction = 0.9 , dynamic_friction = 0.9 , viscous_friction = 0 , override_impact_capture_velocity = 0.001 , override_stiction_transition_velocity = 0.001 )","title":"pcg_gazebo.simulation.physics"},{"location":"reference/simulation_physics/#pcg_gazebosimulationphysics","text":"","title":"pcg_gazebo.simulation.physics"},{"location":"reference/simulation_physics/#bullet","text":"Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = True , split_impulse_penetration_threshold =- 0.01 )","title":"Bullet"},{"location":"reference/simulation_physics/#ode","text":"ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_rescaling = False , friction_model = 'pyramid_model' , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , contact_max_correcting_vel = 100 )","title":"ODE"},{"location":"reference/simulation_physics/#physics","text":"Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False )","title":"Physics"},{"location":"reference/simulation_physics/#simbody","text":"Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 0.5 , static_friction = 0.9 , dynamic_friction = 0.9 , viscous_friction = 0 , override_impact_capture_velocity = 0.001 , override_stiction_transition_velocity = 0.001 )","title":"Simbody"},{"location":"reference/simulation_properties/","text":"pcg_gazebo.simulation.properties \u00b6 Axis \u00b6 Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit =- 1 , effort_limit =- 1 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , use_parent_model_frame = False ) BoundingBox \u00b6 BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ]) Collision \u00b6 Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = None , mu2 = None , friction = None , friction2 = None , slip1 = None , slip2 = None , rolling_friction = None , fdir1 = None , max_contacts = None , soft_cfm = None , soft_erp = None , kp = None , kd = None , max_vel = None , min_depth = None , split_impulse = None , split_impulse_penetration_threshold = None , restitution_coefficient = None , threshold = None , collide_bitmask = None , collide_without_contact = None , collide_without_contact_bitmask = None , category_bitmask = None , poissons_ratio = None , elastic_modulus = None ) Footprint \u00b6 Footprint ( self ) Geometry \u00b6 Geometry ( self , geo_type = None , ** kwargs ) Inertial \u00b6 Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Material \u00b6 Material ( self ) Mesh \u00b6 Mesh ( self , filename = None , load_mesh = False ) Noise \u00b6 Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' ) Plugin \u00b6 Plugin ( self , name = None , filename = None ) Pose \u00b6 Pose ( self , pos = [ 0 , 0 , 0 ], rot = None ) Visual \u00b6 Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"pcg_gazebo.simulation.properties"},{"location":"reference/simulation_properties/#pcg_gazebosimulationproperties","text":"","title":"pcg_gazebo.simulation.properties"},{"location":"reference/simulation_properties/#axis","text":"Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit =- 1 , effort_limit =- 1 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , use_parent_model_frame = False )","title":"Axis"},{"location":"reference/simulation_properties/#boundingbox","text":"BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ])","title":"BoundingBox"},{"location":"reference/simulation_properties/#collision","text":"Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = None , mu2 = None , friction = None , friction2 = None , slip1 = None , slip2 = None , rolling_friction = None , fdir1 = None , max_contacts = None , soft_cfm = None , soft_erp = None , kp = None , kd = None , max_vel = None , min_depth = None , split_impulse = None , split_impulse_penetration_threshold = None , restitution_coefficient = None , threshold = None , collide_bitmask = None , collide_without_contact = None , collide_without_contact_bitmask = None , category_bitmask = None , poissons_ratio = None , elastic_modulus = None )","title":"Collision"},{"location":"reference/simulation_properties/#footprint","text":"Footprint ( self )","title":"Footprint"},{"location":"reference/simulation_properties/#geometry","text":"Geometry ( self , geo_type = None , ** kwargs )","title":"Geometry"},{"location":"reference/simulation_properties/#inertial","text":"Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 )","title":"Inertial"},{"location":"reference/simulation_properties/#material","text":"Material ( self )","title":"Material"},{"location":"reference/simulation_properties/#mesh","text":"Mesh ( self , filename = None , load_mesh = False )","title":"Mesh"},{"location":"reference/simulation_properties/#noise","text":"Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' )","title":"Noise"},{"location":"reference/simulation_properties/#plugin","text":"Plugin ( self , name = None , filename = None )","title":"Plugin"},{"location":"reference/simulation_properties/#pose","text":"Pose ( self , pos = [ 0 , 0 , 0 ], rot = None )","title":"Pose"},{"location":"reference/simulation_properties/#visual","text":"Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"Visual"},{"location":"reference/simulation_sensors/","text":"pcg_gazebo.simulation.sensors \u00b6 Camera \u00b6 Camera ( self , name = 'camera' , type = 'camera' , camera_name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ]) Contact \u00b6 Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' ) IMU \u00b6 IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Ray \u00b6 Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 ) Sensor \u00b6 Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) pose \u00b6 pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pcg_gazebo.simulation.sensors"},{"location":"reference/simulation_sensors/#pcg_gazebosimulationsensors","text":"","title":"pcg_gazebo.simulation.sensors"},{"location":"reference/simulation_sensors/#camera","text":"Camera ( self , name = 'camera' , type = 'camera' , camera_name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ])","title":"Camera"},{"location":"reference/simulation_sensors/#contact","text":"Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' )","title":"Contact"},{"location":"reference/simulation_sensors/#imu","text":"IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"IMU"},{"location":"reference/simulation_sensors/#ray","text":"Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 )","title":"Ray"},{"location":"reference/simulation_sensors/#sensor","text":"Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"Sensor"},{"location":"reference/simulation_sensors/#pose","text":"pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pose"},{"location":"reference/task_manager/","text":"pcg_gazebo.task_manager \u00b6 This module holds all entities related to task scheduling and stages. is_roscore_running \u00b6 is_roscore_running ( ros_master_uri = 'http://localhost:11311' ) Return True if a roscore is running for the provided ROS URI Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target roscore node to be tested is_gazebo_running \u00b6 is_gazebo_running ( ros_master_uri = 'http://localhost:11311' ) Return True if an instance of Gazebo is running and was initialized are a ROS node. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosparam_list \u00b6 get_rosparam_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS parameter names in the parameter server running under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rostopic_list \u00b6 get_rostopic_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS topic names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosservice_list \u00b6 get_rosservice_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS service names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested GazeboProxy \u00b6 GazeboProxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) ProcessManager \u00b6 ProcessManager ( self , label = 'default' , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , output_log_dir = None ) ROSConfig \u00b6 ROSConfig ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 ) Server \u00b6 Server ( self ) SimulationTimer \u00b6 SimulationTimer ( self , simulation_timeout = 0 , start_gazebo_timeout = 60 , ros_config = None , output_log_dir = None , callback = None ) Stage \u00b6 Stage ( self , name ) Task \u00b6 Task ( self , task_name , command , params , config , has_gazebo = False , type = None , required = False , process_timeout = None , task_killed_callback = None , stage = None , output_log_dir = None , simulation_timeout = None )","title":"pcg_gazebo.task_manager"},{"location":"reference/task_manager/#pcg_gazebotask_manager","text":"This module holds all entities related to task scheduling and stages.","title":"pcg_gazebo.task_manager"},{"location":"reference/task_manager/#is_roscore_running","text":"is_roscore_running ( ros_master_uri = 'http://localhost:11311' ) Return True if a roscore is running for the provided ROS URI Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target roscore node to be tested","title":"is_roscore_running"},{"location":"reference/task_manager/#is_gazebo_running","text":"is_gazebo_running ( ros_master_uri = 'http://localhost:11311' ) Return True if an instance of Gazebo is running and was initialized are a ROS node. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"is_gazebo_running"},{"location":"reference/task_manager/#get_rosparam_list","text":"get_rosparam_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS parameter names in the parameter server running under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rosparam_list"},{"location":"reference/task_manager/#get_rostopic_list","text":"get_rostopic_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS topic names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rostopic_list"},{"location":"reference/task_manager/#get_rosservice_list","text":"get_rosservice_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS service names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rosservice_list"},{"location":"reference/task_manager/#gazeboproxy","text":"GazeboProxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None )","title":"GazeboProxy"},{"location":"reference/task_manager/#processmanager","text":"ProcessManager ( self , label = 'default' , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , output_log_dir = None )","title":"ProcessManager"},{"location":"reference/task_manager/#rosconfig","text":"ROSConfig ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 )","title":"ROSConfig"},{"location":"reference/task_manager/#server","text":"Server ( self )","title":"Server"},{"location":"reference/task_manager/#simulationtimer","text":"SimulationTimer ( self , simulation_timeout = 0 , start_gazebo_timeout = 60 , ros_config = None , output_log_dir = None , callback = None )","title":"SimulationTimer"},{"location":"reference/task_manager/#stage","text":"Stage ( self , name )","title":"Stage"},{"location":"reference/task_manager/#task","text":"Task ( self , task_name , command , params , config , has_gazebo = False , type = None , required = False , process_timeout = None , task_killed_callback = None , stage = None , output_log_dir = None , simulation_timeout = None )","title":"Task"},{"location":"reference/visualization/","text":"pcg_gazebo.visualization \u00b6","title":"pcg_gazebo.visualization"},{"location":"reference/visualization/#pcg_gazebovisualization","text":"","title":"pcg_gazebo.visualization"}]}