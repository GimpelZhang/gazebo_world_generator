{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pcg_gazebo : A Python package for rapid-prototyping and scripting of simulations for Gazebo \u00b6 The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information. Purpose of the project \u00b6 This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262). Installation \u00b6 Using pip \u00b6 You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager . From source \u00b6 First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git pip install . Using the package with ROS and Gazebo \u00b6 Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-* License \u00b6 Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"Home"},{"location":"#pcg_gazebo-a-python-package-for-rapid-prototyping-and-scripting-of-simulations-for-gazebo","text":"The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information.","title":"pcg_gazebo: A Python package for rapid-prototyping and scripting of simulations for Gazebo"},{"location":"#purpose-of-the-project","text":"This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262).","title":"Purpose of the project"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-pip","text":"You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager .","title":"Using pip"},{"location":"#from-source","text":"First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git pip install .","title":"From source"},{"location":"#using-the-package-with-ros-and-gazebo","text":"Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-*","title":"Using the package with ROS and Gazebo"},{"location":"#license","text":"Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"License"},{"location":"examples/","text":"This folder contains a number of examples demonstrating the features of the pcg_gazebo package. To run the Jupyter notebooks, be sure to install it as pip install jupyterlab Model generation \u00b6 Creating full Gazebo models in Python \u00b6 In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo. Model group generator \u00b6 In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created. Model factory \u00b6 In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo. Generating models from a YAML configuration file \u00b6 This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME Generating models from template Jinja files \u00b6 This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation. World generation \u00b6 Dynamically generating worlds from YAML configuration file \u00b6 The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other. Occupancy grid map generation \u00b6 Occupancy grid maps can be computed from single models, model groups or worlds using ray tracing. In this notebook it is demonstrated how a grid map can be plotted and stored from a generated world. Parsers \u00b6 Parsing xacro files \u00b6 This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object. SDF parsers \u00b6 The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements URDF parsers \u00b6 The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements","title":"Examples"},{"location":"examples/#model-generation","text":"","title":"Model generation"},{"location":"examples/#creating-full-gazebo-models-in-python","text":"In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo.","title":"Creating full Gazebo models in Python"},{"location":"examples/#model-group-generator","text":"In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created.","title":"Model group generator"},{"location":"examples/#model-factory","text":"In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo.","title":"Model factory"},{"location":"examples/#generating-models-from-a-yaml-configuration-file","text":"This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME","title":"Generating models from a YAML configuration file"},{"location":"examples/#generating-models-from-template-jinja-files","text":"This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation.","title":"Generating models from template Jinja files"},{"location":"examples/#world-generation","text":"","title":"World generation"},{"location":"examples/#dynamically-generating-worlds-from-yaml-configuration-file","text":"The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other.","title":"Dynamically generating worlds from YAML configuration file"},{"location":"examples/#occupancy-grid-map-generation","text":"Occupancy grid maps can be computed from single models, model groups or worlds using ray tracing. In this notebook it is demonstrated how a grid map can be plotted and stored from a generated world.","title":"Occupancy grid map generation"},{"location":"examples/#parsers","text":"","title":"Parsers"},{"location":"examples/#parsing-xacro-files","text":"This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object.","title":"Parsing xacro files"},{"location":"examples/#sdf-parsers","text":"The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements","title":"SDF parsers"},{"location":"examples/#urdf-parsers","text":"The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements","title":"URDF parsers"},{"location":"scripts/","text":"Executable scripts installed with the pcg_gazebo package for command line actions. generate_occupancy_map \u00b6 Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information. generate_pcg_world \u00b6 Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. Examples launch_pcg_world script Samples of world configuration files list_gazebo_models \u00b6 Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ list_gazebo_models process_jinja_template \u00b6 Generates a file from a Jinja template. Run process_jinja_template -h for more information. Examples gen_model_from_template script Samples of model templates written in Jinja run_model_factory \u00b6 Runs a model factory function from the creators module using a YAML file input with the model description. Run run_model_factory -h for more information. Examples gen_model_from_factory_config script Samples of model factory configuration files sdf2urdf \u00b6 Converts a SDF file into an URDF file. Run sdf2urdf -h for more information. sdflint \u00b6 Checks a SDF file for errors. Run sdflint -h for more information. spawn_sdf_model \u00b6 Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run spawn_sdf_model -h for more information. start_gazebo_world \u00b6 Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run start_gazebo_world -h for more information. urdf2sdf \u00b6 Converts an URDF file into a SDF file. Run urdf2sdf -h for more information. urdflint \u00b6 Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run urdflint -h for more information. view_gazebo_model \u00b6 Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run list_gazebo_models . Examples $ view_gazebo_model --model MODEL_NAME # To display the visual meshes $ view_gazebo_model --model MODEL_NAME --collision # To display the collision meshes view_mesh \u00b6 Opens a mesh file and displays it. Run view_mesh -h for more information.","title":"Scripts"},{"location":"scripts/#generate_occupancy_map","text":"Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information.","title":"generate_occupancy_map"},{"location":"scripts/#generate_pcg_world","text":"Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. Examples launch_pcg_world script Samples of world configuration files","title":"generate_pcg_world"},{"location":"scripts/#list_gazebo_models","text":"Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ list_gazebo_models","title":"list_gazebo_models"},{"location":"scripts/#process_jinja_template","text":"Generates a file from a Jinja template. Run process_jinja_template -h for more information. Examples gen_model_from_template script Samples of model templates written in Jinja","title":"process_jinja_template"},{"location":"scripts/#run_model_factory","text":"Runs a model factory function from the creators module using a YAML file input with the model description. Run run_model_factory -h for more information. Examples gen_model_from_factory_config script Samples of model factory configuration files","title":"run_model_factory"},{"location":"scripts/#sdf2urdf","text":"Converts a SDF file into an URDF file. Run sdf2urdf -h for more information.","title":"sdf2urdf"},{"location":"scripts/#sdflint","text":"Checks a SDF file for errors. Run sdflint -h for more information.","title":"sdflint"},{"location":"scripts/#spawn_sdf_model","text":"Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run spawn_sdf_model -h for more information.","title":"spawn_sdf_model"},{"location":"scripts/#start_gazebo_world","text":"Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run start_gazebo_world -h for more information.","title":"start_gazebo_world"},{"location":"scripts/#urdf2sdf","text":"Converts an URDF file into a SDF file. Run urdf2sdf -h for more information.","title":"urdf2sdf"},{"location":"scripts/#urdflint","text":"Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run urdflint -h for more information.","title":"urdflint"},{"location":"scripts/#view_gazebo_model","text":"Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run list_gazebo_models . Examples $ view_gazebo_model --model MODEL_NAME # To display the visual meshes $ view_gazebo_model --model MODEL_NAME --collision # To display the collision meshes","title":"view_gazebo_model"},{"location":"scripts/#view_mesh","text":"Opens a mesh file and displays it. Run view_mesh -h for more information.","title":"view_mesh"},{"location":"reference/generators/","text":"pcg_gazebo.generators The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints. AssetsManager AssetsManager ( self ) Assets manager containing all valid Gazebo models and model group generators. This collection should be initialized as a singleton object in order to have a single source of model to all instances of engines, model and world generators. The asset types allowed to be added are: pcg_gazebo.simulation.SimulationModel : Description for a model pcg_gazebo.simulation.Light : Description for light sources pcg_gazebo.simulation.ModelGroup : Group of models and light sources pcg_gazebo.generators.ModelGroupGenerator : Dynamic model group generator dict : Input configuration of the creators factory methods for box , sphere , cylinder and mesh models, for an instance of pcg_gazebo.simulation.Light , or an instance of pcg_gazebo.generators.ModelGroupGenerator str : Name of an existing Gazebo model that can be found in the Gazebo resources path ground_planes list : List of strings with tags of ground plane models tags list : List of strings with all asset tags get_instance AssetsManager . get_instance () Return singleton instance of the AssetsMananger is_model AssetsManager . is_model ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.SimulationModel . Input arguments tag ( type: str ): Tag of the asset. is_light AssetsManager . is_light ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.Light . Input arguments tag ( type: str ): Tag of the asset. is_model_group AssetsManager . is_model_group ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.ModelGroup . Input arguments tag ( type: str ): Tag of the asset. is_gazebo_model AssetsManager . is_gazebo_model ( self , tag ) Return if asset identified by tag is a Gazebo model found in Gazebo's resources path. Input arguments tag ( type: str ): Tag of the asset. is_model_group_generator AssetsManager . is_model_group_generator ( self , tag ) Return if asset identified by tag is an instance of pcg_gazebo.generators.ModelGroupGenerator . Input arguments tag ( type: str ): Tag of the asset. is_ground_plane AssetsManager . is_ground_plane ( self , tag ) Return if asset identified by tag is flagged as a ground plane model. Input arguments tag ( type: str ): Tag of the asset. is_factory_input AssetsManager . is_factory_input ( self , tag ) Return if asset identified by tag is a dict containing the inputs for a pcg_gazebo.generators.creators factory method to create a box , sphere , cylinder or mesh model. Input arguments tag ( type: str ): Tag of the asset. add AssetsManager . add ( self , description , tag = None , type = None , parameters = None , include_dir = None ) Add new asset to the collection. Input arguments description ( type: str , dict , pcg_gazebo.simulation.SimulationModel , pcg_gazebo.simulation.Light , pcg_gazebo.simulation.ModelGroup or pcg_gazebo.generators.ModelGroupGenerator ): Model description. tag ( type: str , default: None ): Asset's tag. If None is provided, the input description must have an attribute name which will be used as a tag, otherwise the function returns False . type ( type: str , default: None ): When the provided description is dict , the type of asset that must be generated with the dict input must be then provided as either factory , model_generator or light . Returns True , if asset could be added to the collection. get AssetsManager . get ( self , tag , * args , ** kwargs ) Return an asset reference by tag . Input arguments tag ( type: str ): Tag of the asset. In case tag is referencing a pcg_gazebo.generators.ModelGroupGenerator , additional inputs to run the engines can be provided using *args and **kwargs . Returns pcg_gazebo.simulation.SimulationModel or pcg_gazebo.simulation.ModelGroup . None , if tag is invalid. set_asset_as_ground_plane AssetsManager . set_asset_as_ground_plane ( self , tag ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments tag ( type: str ): Name of the model asset from_dict AssetsManager . from_dict ( self , config ) Read assets from an input dict . The dictionary should have a list of asset descriptions under the tag assets and, if necessary, a list of strings referring to models that must be flagged as ground plane under the tag ground_plane . Input arguments config ( type: data_type , default: data ): Parameter description Returns Description of return values from_yaml AssetsManager . from_yaml ( self , filename ) Load the assets from a YAML file. Input arguments filename ( type: str ): YAML filename. CollisionChecker CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. scene trimesh.scene.Scene : Collision check scenario reset_scenario CollisionChecker . reset_scenario ( self ) Remove all meshes from collision check scene. reset_to_fixed_model_scenario CollisionChecker . reset_to_fixed_model_scenario ( self ) Remove all meshes that were not generated by a fixed-pose engine. add_fixed_model CollisionChecker . add_fixed_model ( self , model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure add_model CollisionChecker . add_model ( self , model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure show CollisionChecker . show ( self ) Display the current collision check scenario using pyglet . check_collision_with_current_scene CollisionChecker . check_collision_with_current_scene ( self , model ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise. check_for_collisions CollisionChecker . check_for_collisions ( self ) Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise. ConstraintsManager ConstraintsManager ( self ) add ConstraintsManager . add ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created EngineManager EngineManager ( self ) add EngineManager . add ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. from_yaml EngineManager . from_yaml ( self , filename ) Load the engines from a YAML file. Input arguments filename ( type: str ): YAML filename. ModelGroupGenerator ModelGroupGenerator ( self , name = 'generator' ) SingletonCollisionChecker SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance() . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. get_instance SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance WorldGenerator WorldGenerator ( self , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo.task_manager.GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime. assets List of pcg_gazebo.simulation.SimulationModel : List of model assets that will be used of the world generation. constraints dict of pcg_gazebo.generators.constraints : Dictionary with the positioning constraints. engines dict of pcg_gazebo.generators.engines : Dictionary with the model creation engines. gazebo_proxy pcg_gazebo.task_manager.GazeboProxy : Internal instance of the GazeboProxy name str : Name of the generated world world pcg_gazebo.simulation.World : World abstraction instance init_gazebo_proxy WorldGenerator . init_gazebo_proxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server add_engine WorldGenerator . add_engine ( self , tag , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. add_constraint WorldGenerator . add_constraint ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created add_asset WorldGenerator . add_asset ( self , * args , ** kwargs ) Add a new model asset that can be used by the engines and added to the generated world. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model set_model_as_ground_plane WorldGenerator . set_model_as_ground_plane ( self , model_name ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments model_name ( type: str ): Name of the model asset get_asset WorldGenerator . get_asset ( self , name ) Return a simulation model asset. Input arguments name ( type: str ): Name of the model asset. Returns The model asset as pcg_gazebo.simulation.SimulationModel . None if name cannot be found in the list of model assets. get_constraint WorldGenerator . get_constraint ( self , name ) Return a positioning constraint configuration. Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values add_gazebo_model_as_asset WorldGenerator . add_gazebo_model_as_asset ( self , gazebo_model_name ) Create a model asset by importing a Gazebo model that already exists in the resources path of the catkin workspace. The model's SDF file will be parsed and converted into a pcg_gazebo.simulation.SimulationModel instance. Models that include lights can also be added, but will not be considered assets, they will just be included into the generated world SDF file. Input arguments gazebo_model_name ( type: str ): ID name from the Gazebo model to be imported Returns True if Gazebo model could be included in the assets list. is_asset WorldGenerator . is_asset ( self , name ) Return True if the model identified by the string name is part of the list of assets. Input arguments name ( type: str ): Name of the model add_model WorldGenerator . add_model ( self , model , poses ) Add an instance of pcg_gazebo.simulation.SimulationModel to the world in designed poses. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Parameter description poses ( type: list ): List of 6D pose vectors add_gazebo_model WorldGenerator . add_gazebo_model ( self , model_name , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Add an existent Gazebo model to the world in designed poses. Input arguments model_name ( type: str ): ID name of the Gazebo model pose ( type: list ): 6D pose vector remove_asset WorldGenerator . remove_asset ( self , name ) Remove model asset from the list of assets. Input arguments name ( type: str ): Name of the model Returns True , if model could be removed. delete_model WorldGenerator . delete_model ( self , model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation. add_lights_from_gazebo_model WorldGenerator . add_lights_from_gazebo_model ( self , model_name ) Add light models to the generated world from a Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns True if the lights could be parsed and added to the world. from_dict WorldGenerator . from_dict ( self , config ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, # it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values spawn_model WorldGenerator . spawn_model ( self , model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo.simulation.SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [0, 0, 0] ): Spawning position wrt reference frame rot ( type: list , default: [0, 0, 0] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned. get_physics_engine WorldGenerator . get_physics_engine ( self , engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo.simulation.physics.Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo.simulation.physics.Physics object. run_engines WorldGenerator . run_engines ( self , attach_models = False ) Run all the model placement engines and add the generated models in the internal instance of the world representation. Input arguments attach_models ( type: bool , default: False ): Attach the generated models to the existent list of models in the world Returns True if all engines ran successfully. reset_world WorldGenerator . reset_world ( self , name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [0, 0, -9.8] ): Gravitational acceleration vector export_world WorldGenerator . export_world ( self , output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str plot_results WorldGenerator . plot_results ( self , fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"pcg_gazebo.generators"},{"location":"reference/generators_components/","text":"pcg_gazebo.generators.components HingedDoor HingedDoor ( self , door_mesh_filename = None , width = 0.6 , thickness = 0.04 , height = 2.0 , mass = 10 , set_origin_to_ground = True , fix_to_world = True , hand_convention = 'LH' , max_opening_angle = 1.5707963267948966 , name = 'door' , frame_mesh_filename = None , with_frame = True , frame_width = 0.05 , frame_height = 0.05 , frame_depth = 0.05 ) Walls Walls ( self , height , thickness = 0.1 , geometries = None , model_name = 'wall' , cap_style = 'square' , join_style = 'mitre' )","title":"pcg_gazebo.generators.components"},{"location":"reference/generators_constraints/","text":"pcg_gazebo.generators.constraints Spatial constraints for the placement of simulation entities into the world. Constraint Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class. TangentConstraint TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented ) apply_constraint TangentConstraint . apply_constraint ( self , model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference WorkspaceConstraint WorkspaceConstraint ( self , geometry = None , frame = 'world' , holes = None ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace generate_geometry WorkspaceConstraint . generate_geometry ( self , type , description ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry get_bounds WorkspaceConstraint . get_bounds ( self ) Return the polygon bounds get_random_position WorkspaceConstraint . get_random_position ( self ) Return a random position that belongs to the workspace contains_point WorkspaceConstraint . contains_point ( self , point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy.ndarray ): 2D point contains_polygons WorkspaceConstraint . contains_polygons ( self , polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely.Polygon ): List of polygons get_geometry WorkspaceConstraint . get_geometry ( self ) Return the workspace geometry","title":"pcg_gazebo.generators.constraints"},{"location":"reference/generators_engines/","text":"pcg_gazebo.generators.engines Pose generator engine definitions that compute the pose of the models according to pre-defined rules. Engine Engine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , constraints = None , collision_checker = None ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. Input arguments callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. label str : Engine name identifier models List of str : List of model name tags regarding the engine's model assets poses dict : List of fixed poses associated with model names. add_local_constraint Engine . add_local_constraint ( self , model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition get_local_constraints_for_model Engine . get_local_constraints_for_model ( self , model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned. apply_local_constraints Engine . apply_local_constraints ( self , model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model instance Returns pcg_gazebo.simulation.SimulationModel : Model with modified pose. add_model Engine . add_model ( self , model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model set_fixed_pose_models Engine . set_fixed_pose_models ( self , models ) Function description Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values run Engine . run ( self ) This function should be implemented by the derived classes. FixedPoseEngine FixedPoseEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , collision_checker = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses. add_pose FixedPoseEngine . add_pose ( self , pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses. run FixedPoseEngine . run ( self ) Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo.simulation.SimulationModel : Model instances. PatternEngine PatternEngine ( self , assets_manager , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], mode = None , args = None , collision_checker = None ) RandomPoseEngine RandomPoseEngine ( self , assets_manager = None , callback_fcn_get_constraint = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' , collision_checker = None ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments assets_manager ( type: pcg_gazebo.generators.AssetsManager ) callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on # workspaces, check the # class definition for # `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793 reset_counter RandomPoseEngine . reset_counter ( self ) Reset all model counters. increase_counter RandomPoseEngine . increase_counter ( self , name ) Increase the counter for a model. Input arguments name ( type: str ): Model name get_num_models RandomPoseEngine . get_num_models ( self , name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models get_max_num_models RandomPoseEngine . get_max_num_models ( self , name ) Return the defined maximum number of instances for a model. Input arguments name ( type: str ): Model name Returns int : Maximum number of instances choose_model RandomPoseEngine . choose_model ( self , models = None ) Select the next model instance to be placed in the world. This method is affected by the constructor input model_picker . In case the model_picker option was set as random , a random model will be chosen from the assets available. If it is area , the models will be ordered by footprint size and the models are chosen by an descending footprint size. Returns pcg_gazebo.simulation.SimulationModel : Chosen model is_model_in_workspace RandomPoseEngine . is_model_in_workspace ( self , model ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace get_list_of_footprint_polygons RandomPoseEngine . get_list_of_footprint_polygons ( self , footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely.geometry.Polygon : List of footprint polygons has_collision RandomPoseEngine . has_collision ( self , model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Returns bool : True , if any collision is detected run RandomPoseEngine . run ( self ) Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo.simulation.SimulationModel","title":"pcg_gazebo.generators.engines"},{"location":"reference/log/","text":"pcg_gazebo.log Global logging methods. update_log_dir update_log_dir ( add_timestamp = True ) Update the output folder for log files. Input arguments add_timestamp ( type: bool , default: True ): Add timestamp to folder name. change_log_root_dir change_log_root_dir ( root_dir , update_log_dir = False , add_timestamp = True ) Change the directory for the output log files. Input arguments root_dir ( type: str ): New output log directory. update_log_dir ( type: bool , default: False ): Update current global path for log directory. add_timestamp ( type: bool , default: True ): Add timestamp to the directory folder name. get_log_dir get_log_dir () Return the current output log directory. create_logger create_logger ( name , log_filename = None , output_dir = None , log_level = 40 ) Create new instance of the logger. Input arguments name ( type: str ): Name of the instance. log_filename ( type: str , default: None ): Name of the log filename, if None use name as filename. output_dir ( type: str , default: data ): Output log directory. If None is provided, use the current log directory PCG_LOG_DIR . log_level ( type: int , default: logging.ERROR ): Log level. Returns Logger object.","title":"pcg_gazebo.log"},{"location":"reference/parsers/","text":"pcg_gazebo.parsers Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications parse_sdf parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_urdf parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_sdf_config parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_xml parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections.OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_str parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections.OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_dict parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections.OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections.OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo.parsers.types.XMLBase object. convert_to_dict convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo.parsers.types.XMLBase . Input arguments xml_dict ( type: collections.OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary. convert_from_string convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str . sdf2urdf sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid SDF element Returns pcg_gazebo.parsers.types.XMLBase as an URDF element. urdf2sdf urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid URDF element Returns pcg_gazebo.parsers.types.XMLBase as a SDF element.","title":"pcg_gazebo.parsers"},{"location":"reference/parsers_sdf/","text":"pcg_gazebo.parsers.sdf Accel Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1.4 Source <accel> (SDF 1.4) bias_mean Return the bias mean value SDF element, to read the value use obj.bias_mean.value bias_stddev Return the bias standard deviation value SDF element, to read the value use obj.bias_stddev.value mean Return the mean value SDF element, to read the value use obj.mean.value stddev Return the standard deviation value SDF element, to read the value use obj.stddev.value Accuracy Accuracy ( self , default = 0.001 ) Actor Actor ( self ) AllowAutoDisable AllowAutoDisable ( self , default = False ) Altimeter Altimeter ( self ) AlwaysOn AlwaysOn ( self , default = False ) Ambient Ambient ( self , default = [ 0 , 0 , 0 , 1 ]) AngularVelocity AngularVelocity ( self ) Animation Animation ( self ) Attenuation Attenuation ( self ) AutoStart AutoStart ( self , default = True ) Axis Axis ( self ) Axis2 Axis2 ( self ) Background Background ( self , default = [ 0 , 0 , 0 , 1 ]) BiasMean BiasMean ( self , default = 0 ) BiasStdDev BiasStdDev ( self , default = 0 ) Bounce Bounce ( self ) Box Box ( self ) Bullet Bullet ( self , mode = 'physics' ) CFMDamping CFMDamping ( self , default = False ) CFM CFM ( self , default = 0 ) Camera Camera ( self , mode = 'sensor' ) CastShadows CastShadows ( self , default = True ) CategoryBitmask CategoryBitmask ( self , default = 65535 ) Center Center ( self , default = False ) Child Child ( self , default = 'none' ) Clip Clip ( self ) Clouds Clouds ( self ) Coefficient Coefficient ( self , default = 1 ) CollideBitmask CollideBitmask ( self , default = 65535 ) CollideWithoutContact CollideWithoutContact ( self , default = False ) CollideWithoutContactBitmask CollideWithoutContactBitmask ( self , default = True ) Collision Collision ( self ) Color Color ( self , default = [ 1 , 1 , 1 , 1 ]) Constant Constant ( self , default = 0 ) Constraints Constraints ( self , engine = 'ode' ) Contact Contact ( self , mode = 'simbody' ) ContactMaxCorrectingVel ContactMaxCorrectingVel ( self , default = 100 ) ContactSurfaceLayer ContactSurfaceLayer ( self , default = 0.001 ) Cylinder Cylinder ( self ) Damping Damping ( self , default = 0 ) DelayStart DelayStart ( self , default = 0 ) Density Density ( self , default = 0 ) DepthCamera DepthCamera ( self ) Diffuse Diffuse ( self , default = [ 0 , 0 , 0 , 1 ]) Direction Direction ( self , default = [ 0 , 0 , - 1 ]) Dissipation Dissipation ( self , default = 100 ) Distortion Distortion ( self ) DynamicFriction DynamicFriction ( self , default = 0.9 ) Dynamics Dynamics ( self ) ERP ERP ( self , default = 0.2 ) Effort Effort ( self , default =- 1 ) ElasticModulus ElasticModulus ( self , default =- 1 ) Emissive Emissive ( self , size = 4 ) Empty Empty ( self ) EnableWind EnableWind ( self , default = False ) End End ( self , default = 0 ) FDir1 FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector FallOff FallOff ( self , default = 0 ) Far Far ( self , default = 0 ) Filename Filename ( self , default = 'none' ) Fog Fog ( self , mode = '' ) ForceTorque ForceTorque ( self ) Format Format ( self , default = 'R8G8B8' ) Frame Frame ( self , default = '' ) Friction Friction ( self ) Configuration of the collision friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Friction2 Friction2 ( self , default = 1 ) FrictionModel FrictionModel ( self ) GUI GUI ( self ) Geometry Geometry ( self , mode = 'empty' ) Granularity Granularity ( self , default = 1 ) Gravity Gravity ( self , default = True ) Grid Grid ( self , default = True ) Height Height ( self , default = 1 ) Horizontal Horizontal ( self ) HorizontalFOV HorizontalFOV ( self , default = 1.047 ) Humidity Humidity ( self , default = 0.5 ) IMU IMU ( self ) IXX IXX ( self , default = 0 ) IXY IXY ( self , default = 0 ) IXZ IXZ ( self , default = 0 ) IYY IYY ( self , default = 0 ) IYZ IYZ ( self , default = 0 ) IZZ IZZ ( self , default = 0 ) Image Image ( self , mode = 'geometry' ) Include Include ( self ) Inertia Inertia ( self ) Inertial Inertial ( self ) InheritYaw InheritYaw ( self , default = False ) InitialPosition InitialPosition ( self , default = 0 ) InnerAngle InnerAngle ( self , default = 0 ) InterpolateX InterpolateX ( self , default = False ) Iters Iters ( self , default = 50 ) Joint Joint ( self ) K1 K1 ( self , default = 0 ) K2 K2 ( self , default = 0 ) K3 K3 ( self , default = 0 ) Kd Kd ( self , default = 1 ) Kinematic Kinematic ( self , default = False ) Kp Kp ( self , default = 1000000000000.0 ) LaserRetro LaserRetro ( self , default = 0 ) Length Length ( self ) Light Light ( self ) Lighting Lighting ( self , default = False ) Limit Limit ( self , mode = 'axis' ) Linear Linear ( self , default = 0 ) LinearAcceleration LinearAcceleration ( self ) Link Link ( self ) Localization Localization ( self , default = 'CUSTOM' ) Loop Loop ( self , default = False ) Lower Lower ( self , default =- 1e+16 ) Mass Mass ( self ) Material Material ( self ) Max Max ( self , default = 0 ) MaxAngle MaxAngle ( self , default = 0 ) MaxContacts MaxContacts ( self , default = 20 ) MaxDist MaxDist ( self , default = 0 ) MaxStepSize MaxStepSize ( self , default = 0.001 ) MaxTransientVelocity MaxTransientVelocity ( self , default = 0.01 ) MaxVel MaxVel ( self , default = 0.01 ) Mean Mean ( self ) MeanSize MeanSize ( self , default = 0 ) MeasureDirection MeasureDirection ( self , default = 'child_to_parent' ) Mesh Mesh ( self ) Min Min ( self , default = 0 ) MinAngle MinAngle ( self , default = 0 ) MinDepth MinDepth ( self , default = 0 ) MinDist MinDist ( self , default = 0 ) MinStepSize MinStepSize ( self , default = 0.0001 ) Model Model ( self ) Mu Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Mu2 Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction MustBeLoopJoint MustBeLoopJoint ( self , default = False ) Name Name ( self , default = 'none' ) Near Near ( self , default = 0 ) Noise Noise ( self , type = 'none' ) Normal Normal ( self ) NormalMap NormalMap ( self , default = '' ) ODE ODE ( self , mode = 'physics' ) OrientationReferenceFrame OrientationReferenceFrame ( self ) OriginVisual OriginVisual ( self , default = True ) OuterAngle OuterAngle ( self , default = 0 ) Output Output ( self , default = 'depths' ) OverrideImpactCaptureVelocity OverrideImpactCaptureVelocity ( self , default = 0.001 ) OverrideStictionTransitionVelocity OverrideStictionTransitionVelocity ( self , default = 0.9 ) P1 P1 ( self , default = 0 ) P2 P2 ( self , default = 0 ) Parent Parent ( self , default = 'parent' ) PatchRadius PatchRadius ( self , default = 0 ) Path Path ( self , default = '__default__' ) Physics Physics ( self , mode = 'ode' ) Plane Plane ( self ) PlasticCoefRestitution PlasticCoefRestitution ( self , default = 0.5 ) PlasticImpactVelocity PlasticImpactVelocity ( self , default = 0.5 ) Plugin Plugin ( self , default = {}) Point Point ( self , vec_length = 2 ) PoissonsRatio PoissonsRatio ( self , default = 0.3 ) Polyline Polyline ( self ) Pose Pose ( self ) PreConIters PreConIters ( self , default = 0 ) Precision Precision ( self ) ProvideFeedback ProvideFeedback ( self , default = False ) Quadratic Quadratic ( self , default = 0 ) Radius Radius ( self , default = 0 ) Range Range ( self ) Rate Rate ( self , type = 'none' ) Ray Ray ( self ) RealTimeFactor RealTimeFactor ( self , default = 1 ) RealTimeUpdateRate RealTimeUpdateRate ( self , default = 1 ) Resolution Resolution ( self , default = 0 ) RestitutionCoefficient RestitutionCoefficient ( self , default = 0 ) RollingFriction RollingFriction ( self , default = 1 ) SDF SDF ( self , mode = 'world' ) Samples Samples ( self , default = 640 ) Save Save ( self ) Scale Scale ( self , size = 3 ) Scan Scan ( self ) Scene Scene ( self ) Script Script ( self , mode = 'material' ) SelfCollide SelfCollide ( self , default = False ) Sensor Sensor ( self , mode = 'altimeter' ) Shader Shader ( self ) Shadows Shadows ( self , default = True ) Simbody Simbody ( self , mode = 'physics' ) Size Size ( self , vec_length = 3 ) Skin Skin ( self ) Sky Sky ( self ) Slip Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip1 Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip2 Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient SoftCFM SoftCFM ( self , default = 0 ) SoftERP SoftERP ( self , default = 0.2 ) Solver Solver ( self , engine = 'ode' ) Sor Sor ( self , default = 1.3 ) Specular Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ]) Speed Speed ( self , default = 0.6 ) Sphere Sphere ( self ) SplitImpulse SplitImpulse ( self , default = True ) SplitImpulsePenetrationThreshold SplitImpulsePenetrationThreshold ( self , default =- 0.01 ) Spot Spot ( self ) SpringReference SpringReference ( self , default = 0 ) SpringStiffness SpringStiffness ( self , default = 0 ) Start Start ( self , default = 0 ) Static Static ( self , default = False ) StaticFriction StaticFriction ( self , default = 0.9 ) StdDev StdDev ( self ) Stiffness Stiffness ( self , default = 100000000.0 ) SubMesh SubMesh ( self ) Sunrise Sunrise ( self , default = 0 ) Sunset Sunset ( self , default = 0 ) Surface Surface ( self ) SurfaceRadius SurfaceRadius ( self , default = 0 ) Threshold Threshold ( self , default = 0 ) Time Time ( self , default = 0 ) Topic Topic ( self , default = 'none' ) Torsional Torsional ( self ) TrackVisual TrackVisual ( self ) Trajectory Trajectory ( self ) Transparency Transparency ( self , default = 0 ) Type Type ( self , default = '' ) URDF URDF ( self , mode = 'model' ) URI URI ( self , default = '' ) UpdateRate UpdateRate ( self , default = 0 ) Upper Upper ( self , default = 1e+16 ) UseDynamicMOIRescaling UseDynamicMOIRescaling ( self , default = False ) UseModelFrame UseModelFrame ( self , default = False ) UseParentModelFrame UseParentModelFrame ( self , default = False ) UsePatchRadius UsePatchRadius ( self , default = True ) Velocity Velocity ( self , default =- 1 ) Vertical Vertical ( self ) VerticalPosition VerticalPosition ( self ) VerticalVelocity VerticalVelocity ( self ) ViewController ViewController ( self , default = 'orbit' ) ViscousFriction ViscousFriction ( self , default = 0 ) Visual Visual ( self ) Visualize Visualize ( self , default = False ) Waypoint Waypoint ( self ) Width Width ( self , default = 320 ) World World ( self ) X X ( self ) XYZ XYZ ( self , default = [ 0 , 0 , 1 ]) Y Y ( self ) Z Z ( self )","title":"pcg_gazebo.parsers.sdf"},{"location":"reference/parsers_sdf_config/","text":"pcg_gazebo.parsers.sdf_config Author Author ( self ) Description Description ( self , default = 'none' ) EMail EMail ( self , default = 'none' ) Model Model ( self ) Name Name ( self , default = 'none' ) SDF SDF ( self , default = 'model.sdf' ) Version Version ( self , default = 'none' )","title":"pcg_gazebo.parsers.sdf_config"},{"location":"reference/parsers_types/","text":"pcg_gazebo.parsers.types XMLBase XMLBase ( self ) attributes dict : XML properties xml_element_name str : Name of the SDF element xml_format str : Name of the XML format XMLBoolean XMLBoolean ( self , default = False ) XMLCustom XMLCustom ( self , default = {}) XMLInteger XMLInteger ( self , default = 0 , min_value = None , max_value = None ) XMLScalar XMLScalar ( self , default = 0 , min_value = None , max_value = None ) XMLString XMLString ( self , default = '' ) XMLVector XMLVector ( self , size = None )","title":"pcg_gazebo.parsers.types"},{"location":"reference/parsers_urdf/","text":"pcg_gazebo.parsers.urdf get_all_urdf_element_classes get_all_urdf_element_classes () Get list of all URDF element classes. create_urdf_element create_urdf_element ( tag , * args ) URDF element factory. Input arguments tag ( type: str ): Name of the URDF element. args : Extra arguments for URDF element constructor. Returns URDF element if tag refers to a valid URDF element. None , otherwise. create_urdf_type create_urdf_type ( tag ) Return handle of the URDF element type. Input arguments tag ( type: str ): Name of the URDF element. Returns URDF element type if tag is valid, None otherwise`. is_urdf_element is_urdf_element ( obj ) Test if XML element is an URDF element. Actuator Actuator ( self ) Axis Axis ( self , default = [ 1 , 0 , 0 ]) Box Box ( self ) Child Child ( self , default = 'link' ) Collision Collision ( self ) Color Color ( self , default = [ 0 , 0 , 0 , 1 ]) Cylinder Cylinder ( self ) Dynamics Dynamics ( self ) Gazebo Gazebo ( self , mode = 'none' , sdf_elements = {}) Geometry Geometry ( self ) HardwareInterface HardwareInterface ( self , default = 'EffortJointInterface' ) Inertia Inertia ( self ) Inertial Inertial ( self ) Joint Joint ( self ) Kd Kd ( self , default = 1 ) Kp Kp ( self , default = 1000000000000.0 ) Limit Limit ( self ) Link Link ( self ) Mass Mass ( self ) Material Material ( self , mode = 'color' ) MaxContacts MaxContacts ( self , default = 20 ) MaxVel MaxVel ( self , default = 0.01 ) MechanicalReduction MechanicalReduction ( self , default = 1 ) Mesh Mesh ( self ) Mimic Mimic ( self ) MinDepth MinDepth ( self , default = 0 ) Mu1 Mu1 ( self , default = 1 ) Mu2 Mu2 ( self , default = 1 ) Origin Origin ( self ) Parent Parent ( self , default = 'link' ) ProvideFeedback ProvideFeedback ( self , default = False ) Robot Robot ( self ) SafetyController SafetyController ( self ) SelfCollide SelfCollide ( self , default = False ) Sphere Sphere ( self ) StopCFM StopCFM ( self , default = 0 ) StopERP StopERP ( self , default = 0.2 ) Texture Texture ( self , default = 'filename' ) Transmission Transmission ( self ) Type Type ( self , default = 'transmission_interface/SimpleTransmission' ) Visual Visual ( self )","title":"pcg_gazebo.parsers.urdf"},{"location":"reference/path/","text":"pcg_gazebo.path Path Path ( self , uri ) Path resolver for ROS and Gazebo model paths. The paths can be resolved if provided as: Absolute path $(find ros_pkg) package:// model:// file:// Input arguments uri ( type: str ): Input path to be resolved. is_valid bool : True if the absolute URI exists. original_uri str : Original URI provided.","title":"pcg_gazebo.path"},{"location":"reference/simulation/","text":"pcg_gazebo.simulation Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo. create_object create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance. get_gazebo_model_folders get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names. load_gazebo_models load_gazebo_models () Search for Gazebo models in the local .gazebo/models folder and in the ROS paths. Returns dict : Information of all Gazebo models found get_gazebo_models get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo/models folder and in the catkin workspace as a dictionary. get_gazebo_model_names get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo/models folders and catkin workspace. get_gazebo_model_ros_pkg get_gazebo_model_ros_pkg ( name ) Return name of the ROS package where the Gazebo model is located, None if it was found in .gazebo/models. is_gazebo_model is_gazebo_model ( name ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model. get_gazebo_model_path get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder get_gazebo_model_sdf get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model.sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo.parsers.types.XMLBase instance as an SDF element. Box Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo.simulation.Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [1, 1, 1] ): Vector with width, length and height of the box, collision pcg_gazebo.simulation.properties.Collision : Return single box-shaped collision model. size List of float : Size of the box as [width, length, height] visual pcg_gazebo.simulation.properties.Visual : Return single box-shaped visual model. to_sdf Box . to_sdf ( self , type = 'model' , name = 'box' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial Box . add_inertial ( self , mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_inertial Box . update_inertial ( self , mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_collision Box . update_collision ( self ) Update collision model according to the current size . update_visual Box . update_visual ( self ) Update visual model according to the current size . Cylinder Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters. collision pcg_gazebo.simulation.properties.Collision : Return single cylinder-shaped collision model. length float : Length of the cylinder in meters radius float : Radius of the cylinder in meters visual pcg_gazebo.simulation.properties.Visual : Return single cylinder-shaped visual model. to_sdf Cylinder . to_sdf ( self , type = 'model' , name = 'cylinder' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. update_inertial Cylinder . update_inertial ( self , mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms update_collision Cylinder . update_collision ( self ) Update collision model according to the current length and radius . update_visual Cylinder . update_visual ( self ) Update visual model according to the current length and radius . Joint Joint ( self , name = 'joint' , parent = None , child = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 , use_parent_model_frame = False ) Light Light ( self , name = 'default' , type = 'point' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , inner_angle = None , outer_angle = None , falloff = None ) Link Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ). collisions List of pcg_gazebo.simulation.properties.Collision : List of collision models creation_time float : Time of creation of this object, if it represents a single-link model. inertial pcg_gazebo.simulation.properties.Inertial : Description of the object's moments of inertia. kinematic bool : Flag to indicate if the model is purely kinematic life_timeout float : Life timeout timestamp for this object, if it represents a single-link model name str : Object name pose pcg_gazebo.simulation.properties.Pose : Pose of the object self_collide bool : Self-collision flag static bool : Flag to indicate if object is static visuals List of pcg_gazebo.simulation.properties.Visual : List of visual models create_link_from_mesh Link . create_link_from_mesh ( name = 'link' , visual_mesh = None , collision_mesh = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' , visual_parameters = {}, collision_parameters = {}) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the visual mesh file or a mesh object. collision_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [0, 0, 0, 0, 0, 0] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict(ixx=0, iyy=0, izz=0, ixy=0, ixz=0, iyz=0) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo.simulation.Link instance. enable_collision Link . enable_collision ( self ) Enable the inclusion of the collision models in the exported SDF description. disable_collision Link . disable_collision ( self ) Disable the inclusion of the collision models in the exported SDF description. enable_visual Link . enable_visual ( self ) Enable the inclusion of the visual models in the exported SDF description. disable_visual Link . disable_visual ( self ) Disable the inclusion of the collision models in the exported SDF description. get_collision_by_name Link . get_collision_by_name ( self , name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo.simulation.properties.Collision , or None if not collision with the given name is found. has_collision Link . has_collision ( self , name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise. get_visual_by_name Link . get_visual_by_name ( self , name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo.simulation.properties.Visual , or None if not visual with the given name is found. has_visual Link . has_visual ( self , name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise. add_empty_visual Link . add_empty_visual ( self , name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists. add_visual Link . add_visual ( self , visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo.simulation.properties.Visual ): Visual element Returns bool : True , if visual element could be added to object. add_empty_collision Link . add_empty_collision ( self , name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists. add_collision Link . add_collision ( self , collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo.simulation.properties.Collision ): Collision element Returns bool : True , if collision element could be added to object. to_sdf Link . to_sdf ( self , type = 'link' , name = 'model' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. from_sdf Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo.simulation.Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.Link ): SDF object Returns pcg_gazebo.simulation.Link : Simulation object instance export_to_gazebo_model Link . export_to_gazebo_model ( self , output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir/ model.sdf model.config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1.6 ): Version of the SDF format version ( type: str , default: 0.1.0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully. add_inertial Link . add_inertial ( self , mass ) This function must be implemented by derived classes. update_inertial Link . update_inertial ( self ) This function must be implemented by derived classes. update_collision Link . update_collision ( self ) This function must be implemented by derived classes. update_visual Link . update_visual ( self ) This function must be implemented by derived classes. add_sensor Link . add_sensor ( self , name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo.simulation.sensors.Sensor ): Sensor description Returns bool : True , if sensor could be added to link. to_markers Link . to_markers ( self ) Generate visualization_msgs/Marker instances from the visual and/or collision entities. Returns visualization_msgs/MarkerArray get_footprint Link . get_footprint ( self , mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon get_meshes Link . get_meshes ( self , mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes. get_bounds Link . get_bounds ( self , mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds ModelGroup ModelGroup ( self , name = 'group' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], is_ground_plane = False ) lights dict : Lights models dict : Models n_lights int : Number of lights n_models int : Number of models reset_models ModelGroup . reset_models ( self ) Reset the list of models. add_model ModelGroup . add_model ( self , tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model ModelGroup . rm_model ( self , tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists ModelGroup . model_exists ( self , tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_include ModelGroup . add_include ( self , include ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_light ModelGroup . add_light ( self , tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light ModelGroup . rm_light ( self , tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists ModelGroup . light_exists ( self , tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. Plane Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ]) Polyline Polyline ( self , name = 'polyline' , height = 1 , points = []) SimulationModel SimulationModel ( self , name = 'model' , parent = 'world' , creation_time = None , life_timeout = None , is_ground_plane = False ) Sphere Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters collision pcg_gazebo.simulation.properties.Collision : Return single sphere-shaped collision model. radius float : Radius of the sphere in meters visual pcg_gazebo.simulation.properties.Visual : Return single sphere-shaped visual model. to_sdf Sphere . to_sdf ( self , type = 'model' , name = 'sphere' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial Sphere . add_inertial ( self , mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one update_inertial Sphere . update_inertial ( self , mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms update_collision Sphere . update_collision ( self ) Update collision model according to the current radius . update_visual Sphere . update_visual ( self ) Update visual model according to the current radius . World World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [0, 0, -9.8] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody . engine str : Name identifier of the physics engine gravity list : Acceleration of gravity vector lights dict : Lights model_groups dict : Model groups models dict : Models name str : Name of the world physics pcg_gazebo.simulation.physics.Physics : Physics engine instance reset_physics World . reset_physics ( self , engine = 'ode' , * args , ** kwargs ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody . reset_models World . reset_models ( self ) Reset the list of models. add_include World . add_include ( self , include , group = 'default' ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_model World . add_model ( self , tag , model , group = 'default' ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model World . rm_model ( self , tag , group = 'default' ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists World . model_exists ( self , tag , group = None ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_plugin World . add_plugin ( self , tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo.parsers.sdf.Plugin or pcg_gazebo.simulation.properties.Plugin ): Plugin description. rm_plugin World . rm_plugin ( self , tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world. plugin_exists World . plugin_exists ( self , tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise. add_light World . add_light ( self , tag , light , group = 'default' ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light World . rm_light ( self , tag , group = 'default' ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists World . light_exists ( self , tag , group = 'default' ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. to_sdf World . to_sdf ( self , type = 'world' , with_default_ground_plane = True , with_default_sun = True ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo.parsers.sdf.SDF with a world element in it or pcg_gazebo.parsers.sdf.World . from_sdf World . from_sdf ( sdf ) Parse an pcg_gazebo.parsers.sdf.World into a World class. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.World ): SDF world element Returns pcg_gazebo.parsers.sdf.World instance. create_scene World . create_scene ( self , mesh_type = 'collision' , add_pseudo_color = True ) Return a trimesh.Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color. plot_footprints World . plot_footprints ( self , fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib.pyplot.Figure or bokeh.plotting.Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib.pyplot.Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0.5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib.pyplot.Figure or bokeh.plotting.Figure .","title":"pcg_gazebo.simulation"},{"location":"reference/simulation_physics/","text":"pcg_gazebo.simulation.physics Bullet Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = True , split_impulse_penetration_threshold =- 0.01 ) ODE ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_rescaling = False , friction_model = 'pyramid_model' , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , contact_max_correcting_vel = 100 ) Physics Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False ) Simbody Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 0.5 , static_friction = 0.9 , dynamic_friction = 0.9 , viscous_friction = 0 , override_impact_capture_velocity = 0.001 , override_stiction_transition_velocity = 0.001 )","title":"pcg_gazebo.simulation.physics"},{"location":"reference/simulation_properties/","text":"pcg_gazebo.simulation.properties Axis Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit =- 1 , effort_limit =- 1 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , use_parent_model_frame = False ) BoundingBox BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ]) Collision Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = None , mu2 = None , friction = None , friction2 = None , slip1 = None , slip2 = None , rolling_friction = None , fdir1 = None , max_contacts = None , soft_cfm = None , soft_erp = None , kp = None , kd = None , max_vel = None , min_depth = None , split_impulse = None , split_impulse_penetration_threshold = None , restitution_coefficient = None , threshold = None , collide_bitmask = None , collide_without_contact = None , collide_without_contact_bitmask = None , category_bitmask = None , poissons_ratio = None , elastic_modulus = None ) Footprint Footprint ( self ) Geometry Geometry ( self , geo_type = None , ** kwargs ) Inertial Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Material Material ( self ) Mesh Mesh ( self , filename = None , load_mesh = False ) Noise Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' ) Plugin Plugin ( self , name = None , filename = None ) Pose Pose ( self , pos = [ 0 , 0 , 0 ], rot = None ) Visual Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"pcg_gazebo.simulation.properties"},{"location":"reference/simulation_sensors/","text":"pcg_gazebo.simulation.sensors Camera Camera ( self , name = 'camera' , type = 'camera' , camera_name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ]) Contact Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' ) IMU IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Ray Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 ) Sensor Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) pose pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pcg_gazebo.simulation.sensors"},{"location":"reference/task_manager/","text":"pcg_gazebo.task_manager This module holds all entities related to task scheduling and stages. is_roscore_running is_roscore_running ( ros_master_uri = 'http://localhost:11311' ) Return True if a roscore is running for the provided ROS URI Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target roscore node to be tested is_gazebo_running is_gazebo_running ( ros_master_uri = 'http://localhost:11311' ) Return True if an instance of Gazebo is running and was initialized are a ROS node. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosparam_list get_rosparam_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS parameter names in the parameter server running under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rostopic_list get_rostopic_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS topic names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosservice_list get_rosservice_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS service names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested GazeboProxy GazeboProxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) ProcessManager ProcessManager ( self , label = 'default' , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , output_log_dir = None ) ROSConfig ROSConfig ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 ) Server Server ( self ) SimulationTimer SimulationTimer ( self , simulation_timeout = 0 , start_gazebo_timeout = 60 , ros_config = None , output_log_dir = None , callback = None ) Stage Stage ( self , name ) Task Task ( self , task_name , command , params , config , has_gazebo = False , type = None , required = False , process_timeout = None , task_killed_callback = None , stage = None , output_log_dir = None , simulation_timeout = None )","title":"pcg_gazebo.task_manager"},{"location":"reference/visualization/","text":"pcg_gazebo.visualization","title":"pcg_gazebo.visualization"}]}